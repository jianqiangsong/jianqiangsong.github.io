{"meta":{"title":"Gemini`s wiki","subtitle":"Gemini","description":"Gemini`s wiki","author":"Gemini","url":"http://example.com","root":"/"},"pages":[{"title":"Categories","date":"2023-08-16T01:20:54.656Z","updated":"2023-08-16T01:20:54.656Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Resume","date":"2023-07-17T14:50:05.746Z","updated":"2023-07-17T14:50:05.746Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人简历 概况：8年工作经验 | 男 | 1990年 | 已婚 | 172cm | 群众 电话：15250351357 E-mail： 15250351357@163.com 地址：深圳 公司：深圳xxx科技有限公司 职位：PHP高级工程师 学校：交通学院 学历：本科 专业：航海技术 自我评价 6年PHP工作经验，3年团队管理经验，项目管理经验丰富。熟练掌握 PHP 编程语言及 OOP 思想。在xxx公司工作期间，先后主要负责的项目有效果图、问答、学装修、新闻中心、商城、图满意、设计师报价系统、oa考试系统等十几个系统，由YII从零搭建。多个项目server端采用Java服务。 熟悉 Yii.thinkphp.ci 开源框架的配置方法及使用，YII实战经验三年，了解原理，能写组件，能扩展gii代码生成工具，基本CURD完全自动化生成，显著提高工作效率； 熟悉网站开发中常见功能的开发：js前端验证技术、面向对象技术，无限极分类， Session cookie技术，正则表达式技术，面包屑导航，ajax无刷新技术，jquery技术，smarty模板技术，mvc开发模式等； 熟练掌握SQL语言，熟练运用Mysql关系型数据库以及各种客户端工具；熟悉LINUX基本命令及Apache服务器相关配置，lamp环境搭建；掌握并能应用nosql产品，如memcached、readis、mongodb。 求职意向 到岗时间：随时 工作性质：全职 目标地点：深圳 期望薪资：月薪 20000-24999 目标职能：高级PHP工程师、项目经理 工作经验2013-10 至今：深圳xxx科技有限公司 2000人 3年1个月 职位: PHP高级工程师 部门：技术中心 行业：互联网&#x2F;电子商务 跟产品经理确认需求，按计划完成多个设计与开发； 承担xxx图库及问答两大模块的所有代码开发及维护工作； 带领web组同事，指导技术实现、代码审核。并顺利完成多个项目； 基于 MySQL＋PHP 进行Web产品的设计和开发； 参与完成系统架构设计、数据库结构设计、业务逻辑抽象等编码工作； 配合Java服务组，接入Java服务。 2013-01 – 2013-10：xxx健康科技有限公司 &lt;&#x3D;50人 9个月 职位: PHP工程师 部门：产品研发部 行业：互联网&#x2F;电子商务 开发公司网站新功能； 网站邮件及消息管理功能开发；网站用户注册及数据入口验证 优化网站性能，维护网站bug；数据库维护与备份。 2011-01 – 2012-10：xxx互联科技有限公司 80人 1年9个月 职位: php程序员 部门：技术部门 行业：互联网&#x2F;电子商务 经理的得力助手，帮助他完成一些工作，比如服务器维护，客户网站定时检查和备份； 开发公司项目，收集客户需求，并分配到相应人手中实践； 检验工作成果是否符合要求，并技术实践分析； 指导同事完成项目，探讨新的高效方式去开发网站； 核心代码整理，提高程序的复用性。 项目经验2015-04 至今 xxx商城 软件环境：lnmp 项目描述：xxx商城是2015年上线的以家具建材为主的商城。终端包含pc、h5、app。第一版从设计到开发历时仅一个半月，sku 4000+。 全站使用 yii 框架，前端采用 sea.js，server端采用Java服务进行订单结算和库存管理。在此项目中担任开发项目经理并参与主体功能开发， 商城所完成的主要功能如下： 购物车功能。无登录与登录后，能同步购物车商品； 物流，快递模块。根据不同区域，不同价格策略做设置； 满包邮，满减，满赠送活动功能；专题，秒杀活动管理； sku上下架。及物品快照功能； 用户收货地址管理。 2013-03 至今 xxx装修网 软件环境：lamp 项目描述：xxx效果图和xxx网站的问答 开发、优化升级: 效果图多格式、多规格优化处理，多屏适配；图片的重复检查，水印处理。图片质量压缩及feed文件生成。 xxx业务发展迅猛，网站访问飙升（当前日均300W uv），通过redis，memcache缓存；服务器压力降低50%，访问流畅性、服务器稳定性极大提高； 优化前端代码，实现低耦合，高可用。 xxx网站的问答开发、优化升级 问答的交互代码，回答问题加积分； 问答的管理，及问题批量处理功能； 安全过滤，防止敏感关键词被发布。 责任描述: 带领团队不断成长。在自我驱动、业务驱动的双重动力下，带领的团队紧跟公司节奏，成长迅速； 维护效果图及问吧代码的前后端及版本改造 。 2015-01 – 2015-03 xxx新闻中心 软件环境： lamp 项目描述： 实现xxx新闻的采集及发布，打造权威家居资讯平台。主要包括:新闻、图说、原创视频、人物、活动三大版块。分别以图文，视频，专题等几种形式发布前沿家居信息。此项目以YII为核心技术架构。 责任描述: 带领团队从零开发，历时一个半月设计、开发并顺利上线； 开发方法及质量进度的跟踪，协调产品、测试等资源，保障项目顺利完成； 实现技术难点 如采集，旧版url的兼容，图片处理等。 2013-01 – 2013-10 xxx产品开发 项目描述：xxx项目，是一个健康促进平台。用户可以上传运动数据。知道自己的运动记录。同时可以使用公司指定的器材来上传步行数据。通过这个平台，和其它人PK，获取名次。发动全民健身。该项目基于ECSHOP底层代码二关开发。共划分十三个模块。历时一年半正式上线。 责任描述： 用户注册模块，卡密生成，验证，用户数据分析，勋章获取； 用户消息及邮件通知，参赛报名流程，企业后台管理；数据库优化。 兴趣爱好篮球，爬山"},{"title":"Tags","date":"2023-07-17T08:38:13.747Z","updated":"2023-07-17T08:38:13.747Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"gallery","date":"2020-10-05T04:00:00.000Z","updated":"2023-08-17T09:14:57.351Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":""},{"title":"个人照片","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T01:44:27.873Z","comments":true,"path":"gallery/个人照片/index.html","permalink":"http://example.com/gallery/%E4%B8%AA%E4%BA%BA%E7%85%A7%E7%89%87/index.html","excerpt":"","text":""},{"title":"广州2","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-22T07:51:29.950Z","comments":true,"path":"gallery/广州2/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E2/index.html","excerpt":"","text":""},{"title":"广州10","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:25.945Z","comments":true,"path":"gallery/广州10/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E10/index.html","excerpt":"","text":""},{"title":"广州4","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:02.933Z","comments":true,"path":"gallery/广州4/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E4/index.html","excerpt":"","text":""},{"title":"广州5","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:07.539Z","comments":true,"path":"gallery/广州5/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E5/index.html","excerpt":"","text":""},{"title":"广州","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:37:50.278Z","comments":true,"path":"gallery/广州/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E/index.html","excerpt":"","text":""},{"title":"广州6","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:11.140Z","comments":true,"path":"gallery/广州6/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E6/index.html","excerpt":"","text":""},{"title":"广州8","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:19.151Z","comments":true,"path":"gallery/广州8/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E8/index.html","excerpt":"","text":""},{"title":"广州3","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:15:12.697Z","comments":true,"path":"gallery/广州3/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E3/index.html","excerpt":"","text":""},{"title":"广州9","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:22.579Z","comments":true,"path":"gallery/广州9/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E9/index.html","excerpt":"","text":""},{"title":"生活","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:03:21.300Z","comments":true,"path":"gallery/生活/index.html","permalink":"http://example.com/gallery/%E7%94%9F%E6%B4%BB/index.html","excerpt":"","text":""},{"title":"记录","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:21:31.055Z","comments":true,"path":"gallery/记录/index.html","permalink":"http://example.com/gallery/%E8%AE%B0%E5%BD%95/index.html","excerpt":"","text":""},{"title":"广州7","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-23T01:16:14.895Z","comments":true,"path":"gallery/广州7/index.html","permalink":"http://example.com/gallery/%E5%B9%BF%E5%B7%9E7/index.html","excerpt":"","text":""},{"title":"生活记录","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:06:41.402Z","comments":true,"path":"gallery/生活记录/index.html","permalink":"http://example.com/gallery/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/index.html","excerpt":"","text":""},{"title":"随拍","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:11:03.816Z","comments":true,"path":"gallery/随拍/index.html","permalink":"http://example.com/gallery/%E9%9A%8F%E6%8B%8D/index.html","excerpt":"","text":""},{"title":"随笔","date":"2020-10-02T15:00:17.000Z","updated":"2023-08-18T06:31:48.282Z","comments":true,"path":"gallery/随笔/index.html","permalink":"http://example.com/gallery/%E9%9A%8F%E7%AC%94/index.html","excerpt":"","text":""}],"posts":[{"title":"es","slug":"docker/es","date":"2024-07-12T09:41:55.000Z","updated":"2024-07-18T09:36:44.112Z","comments":true,"path":"2024/07/12/docker/es/","link":"","permalink":"http://example.com/2024/07/12/docker/es/","excerpt":"","text":"默认安装完毕后访问docker run –name es -p 9200:9200 -p 9300:9300 -e “discovery.type&#x3D;single-node” -d elasticsearch:8.4.1 1.导出配置文件后关闭认证docker cp 927e652cadff:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml .&#x2F; docker cp elasticsearch.yml 927e652cadff:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F; 2.然后重启es服务3.安装es&#x2F;ik分词bin&#x2F;elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/8.4.1 根据type进行分组后,id排序取值前三123456789101112131415161718192021222324252627&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;top_score&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;type&quot; &#125;, &quot;aggs&quot;: &#123; &quot;top_score_hits&quot;: &#123; &quot;top_hits&quot;: &#123; &quot;_source&quot;: [ &quot;name&quot;, &quot;id&quot;, &quot;type&quot; ], &quot;size&quot;: 2, &quot;sort&quot;: &#123; &quot;id&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match_all&quot;: &#123;&#125; &#125; ] &#125; &#125;, &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;stationAgg&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;Station&quot;, &quot;size&quot;: 100, &quot;min_doc_count&quot;: 1 &#125;, &quot;aggs&quot;: &#123; &quot;top1&quot;: &#123; &quot;top_hits&quot;: &#123; &quot;size&quot;: 1, &quot;sort&quot;: [ &#123; &quot;time&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ] &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"git 常用笔记","slug":"工具/git-tips","date":"2024-04-17T05:58:34.000Z","updated":"2024-04-17T06:49:48.869Z","comments":true,"path":"2024/04/17/工具/git-tips/","link":"","permalink":"http://example.com/2024/04/17/%E5%B7%A5%E5%85%B7/git-tips/","excerpt":"","text":"日常常用的命令两个版本差异的文件打包123456diff -diff --name-only fe76595f 91f2852b | xargs tar -zcvf 20191027diff.tar.gz# 列出当前文件路径diff -diff --name-only fe76595f 91f2852bgit diff --name-only HEAD^ HEAD 可以显示详细修改了哪些文件1git log --stat 一行显示提交信息1git log --oneline","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"笔记","slug":"git/笔记","permalink":"http://example.com/categories/git/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"other其他","slug":"laravel/Other","date":"2024-03-07T09:34:16.875Z","updated":"2024-03-07T10:02:28.264Z","comments":true,"path":"2024/03/07/laravel/Other/","link":"","permalink":"http://example.com/2024/03/07/laravel/Other/","excerpt":"","text":"其他 localhost配置 何时运行或不运行composer-update Composer检查新版本 自动大写翻译 仅含小时的Carbon 单动作控制器 重定向到特定的控制器方法 使用旧版本的Laravel 为分页链接添加参数 可重复回调函数 $request-&gt;hasAny 简单分页组件 获取数据的方法 Blade指令增加真假条件s 任务允许脱离队列 在工厂类或seeders外部使用Faker 可以定时执行的事情 检索Laravel文档 过滤route-list 自定义Blade指令 Artisan命令帮助 当运行测试时禁用懒加载 使用两个很好用的辅助函数会带来魔法效果 请求参数的默认值 在路由中直接传入中间件而不是注册它 将数组转化成css类 Laravel-Cashier中的upcomingInvoice方法 $request-&gt;exists与has 返回带变量视图的多种方法 调度标准shell命令 无需SSL验证的HTTP请求 不断言任何内容的测试 Str的mask方法 扩展Laravel类 Can特性 临时下载url 处理深度嵌套数组 自定义异常的呈现方式 tap助手函数 重置所有剩余的时间单位 控制台内核中的计划命令问题可以自动通过电子邮件发送其输出 使用GET参数构造自定义筛选查询时要小心 清理你臃肿的路由文件 自定义邮件日志存储位置 markdown简单创建 给中间件传参数 获取并删除session request的date方法 使用分页时请使用through而不是map 定义访问器与修改器的新方法 localhost配置不要忘记将 .env 文件中的 app_url 从 http://localhost 中改为真实的 URL，因为它将是你的电子邮件通知和任何其他链接的基础。 12345APP_NAME=LaravelAPP_ENV=localAPP_KEY=base64:9PHz3TL5C4YrdV6Gg/Xkkmx9btaE93j7rQTUZWm2MqU=APP_DEBUG=trueAPP_URL=http://localhost 何时运行或不运行composer-update与Laravel不是很相关，但是… 永远不要在生产服务器上运行 composer update ，它很慢，会 “破坏” 存储库。始终在你电脑上本地运行 composer update ，将新的 composer.lock 提交到存储库，然后再在生产服务器运行 composer install。 Composer检查新版本如果你想找出 composer.json 包中已经发布的较新版本，直接运行 composer outdated。你会得到一个包含所有信息的完整列表，如下所示。 12345phpdocumentor/type-resolver 0.4.0 0.7.1phpunit/php-code-coverage 6.1.4 7.0.3 Library that provides collection, processing, and rende...phpunit/phpunit 7.5.9 8.1.3 The PHP Unit Testing framework.ralouphie/getallheaders 2.0.5 3.0.3 A polyfill for getallheaders.sebastian/global-state 2.0.0 3.0.0 Snapshotting of global state 自动大写翻译在翻译文件中（resources/lang），你不仅可以指定变量为:variable ，也可以指定大写为:VARIABLE 或 :Variable，然后你传递的值也会自动大写。 12345// resources/lang/en/messages.php&#x27;welcome&#x27; =&gt; &#x27;Welcome, :Name&#x27;// Result: &quot;Welcome, Taylor&quot;echo __(&#x27;messages.welcome&#x27;, [&#x27;name&#x27; =&gt; &#x27;taylor&#x27;]); 仅含小时的Carbon如果你想有当前日期不包含秒或者分钟，用Carbon的方法比如：setSeconds(0) 或者 setMinutes(0)。 1234567891011// 2020-04-20 08:12:34echo now();// 2020-04-20 08:12:00echo now()-&gt;setSeconds(0);// 2020-04-20 08:00:00echo now()-&gt;setSeconds(0)-&gt;setMinutes(0);// Another way - even shorterecho now()-&gt;startOfHour(); 单动作控制器如果你想创建一个只有一个动作的控制器，你可以使用 __invoke() 方法创建「可调用（invokable）」控制器。路由： 1Route::get(&#x27;user/&#123;id&#125;&#x27;, &#x27;ShowProfile&#x27;); Artisan 命令: 1php artisan make:controller ShowProfile --invokable 控制器 123456789class ShowProfile extends Controller&#123; public function __invoke($id) &#123; return view(&#x27;user.profile&#x27;, [ &#x27;user&#x27; =&gt; User::findOrFail($id) ]); &#125;&#125; 重定向到特定的控制器方法你不仅可以 redirect() 到 URL 或特定的路由，而且可以跳转到一个特定的控制器里的特定方法，甚至向其传递参数。像这样： 1return redirect()-&gt;action(&#x27;SomeController@method&#x27;, [&#x27;param&#x27; =&gt; $value]); 使用旧版本的Laravel如果你想用旧版本而非新版本的 Laravel，使用这个命令： 1composer create-project --prefer-dist laravel/laravel project &quot;7.*&quot; 将 7.* 更改为任何你想要的版本。 为分页链接添加参数在默认的分页链接中，你可以传递其他参数，保留原始的查询字符串，甚至指向一个特定的 #xxxxx 锚点。 12345&#123;&#123; $users-&gt;appends([&#x27;sort&#x27; =&gt; &#x27;votes&#x27;])-&gt;links() &#125;&#125;&#123;&#123; $users-&gt;withQueryString()-&gt;links() &#125;&#125;&#123;&#123; $users-&gt;fragment(&#x27;foo&#x27;)-&gt;links() &#125;&#125; 可重复回调函数如果你又一个需要多次重复调用的回调函数，你可以将其声明在一个变量中，然后反复使用它。 123456789$userCondition = function ($query) &#123; $query-&gt;where(&#x27;user_id&#x27;, auth()-&gt;id());&#125;;// Get articles that have comments from this user// And return only those comments from this user$articles = Article::with([&#x27;comments&#x27; =&gt; $userCondition]) -&gt;whereHas(&#x27;comments&#x27;, $userCondition) -&gt;get(); $request-&gt;hasAny你不仅可以使用 $request-&gt;has() 方法来查看一个参数，而且可以使用 $request-&gt;hasAny() 来查看传入的多个参数。 12345678public function store(Request $request) &#123; if ($request-&gt;hasAny([&#x27;api_key&#x27;, &#x27;token&#x27;])) &#123; echo &#x27;We have API key passed&#x27;; &#125; else &#123; echo &#x27;No authorization parameter&#x27;; &#125;&#125; 简单分页组件在分页组件中，如果你只需要「上一页 &#x2F; 下一页」的链接，而不是需要所有页码，也因此可以使用更少的数据库查询，你只需要将 simplePaginate() 更改为 paginate() 12345// Instead of $users = User::paginate(10);// You can do this$users = User::simplePaginate(10); 获取数据的方法如果你有一个具有复杂数据结构的数组，例如带对象嵌套的数组，你可以使用 data_get() 助手函数配合通配符和「点」符号，来从嵌套数组或对象中检索值。 1234567891011121314// We have an array[ 0 =&gt; [&#x27;user_id&#x27; =&gt;&#x27;some user id&#x27;, &#x27;created_at&#x27; =&gt; &#x27;some timestamp&#x27;, &#x27;product&#x27; =&gt; &#123;object Product&#125;, etc], 1 =&gt; [&#x27;user_id&#x27; =&gt;&#x27;some user id&#x27;, &#x27;created_at&#x27; =&gt; &#x27;some timestamp&#x27;, &#x27;product&#x27; =&gt; &#123;object Product&#125;, etc], 2 =&gt; etc]// Now we want to get all products ids. We can do like this:data_get($yourArray, &#x27;*.product.id&#x27;);// Now we have all products ids [1, 2, 3, 4, 5, etc...] Blade指令增加真假条件Laravel 8.51 新增 @class 指令，用于添加控制 CSS 类的真 &#x2F; 假条件。可以在 文档 中了解更多之前: 1&lt;div class=&quot;@if ($active) underline @endif&quot;&gt;` 现在: 1&lt;div @class([&#x27;underline&#x27; =&gt; $active])&gt; 12345678910111213@php $isActive = false; $hasError = true;@endphp&lt;span @class([ &#x27;p-4&#x27;, &#x27;font-bold&#x27; =&gt; $isActive, &#x27;text-gray-500&#x27; =&gt; ! $isActive, &#x27;bg-red&#x27; =&gt; $hasError,])&gt;&lt;/span&gt;&lt;span class=&quot;p-4 text-gray-500 bg-red&quot;&gt;&lt;/span&gt; 由 @Teacoders提供 任务允许脱离队列在文档中，任务是在队列章节进行讨论的，但是你可以脱离队列来使用job，就像传统的委托任务的类一样。只需在控制器中调用 $this-&gt;dispatchNow() 即可。 123456public function approve(Article $article)&#123; // $this-&gt;dispatchNow(new ApproveArticle($article)); //&#125; 在工厂类或seeders外部使用Faker如果你想要生成一些假数据，你可以在模型工厂或 Seeds 中，甚至任何类的外部使用 Faker。 注意：要在生产模式 production 中使用它的话，你需要在 composer.json 中，将 faker 从 “require-dev” 移动到 “require” 中。 12345678910use Faker;class WhateverController extends Controller&#123; public function whatever_method() &#123; $faker = Faker\\Factory::create(); $address = $faker-&gt;streetAddress; &#125;&#125; 可以定时执行的事情你可以让一些事情以每小时、每天，或是其他时间模式执行。 你可以安排 artisan 命令、作业类、可调用类、回调函数、甚至是 shell 脚本去定时执行。 123use App\\Jobs\\Heartbeat;$schedule-&gt;job(new Heartbeat)-&gt;everyFiveMinutes(); 1$schedule-&gt;exec(&#x27;node /home/forge/script.js&#x27;)-&gt;daily(); 12345use App\\Console\\Commands\\SendEmailsCommand;$schedule-&gt;command(&#x27;emails:send Taylor --force&#x27;)-&gt;daily();$schedule-&gt;command(SendEmailsCommand::class, [&#x27;Taylor&#x27;, &#x27;--force&#x27;])-&gt;daily(); 123456protected function schedule(Schedule $schedule)&#123; $schedule-&gt;call(function () &#123; DB::table(&#x27;recent_users&#x27;)-&gt;delete(); &#125;)-&gt;daily();&#125; 检索Laravel文档如果你想使用一些关键词来检索 Laravel 文档，默认情况下只会给出 5 个结果。或许还能给出更多结果。 如果你想要看全部的结果，你可以前往 Laravel 文档 的 Github 仓库 直接搜索。 过滤route-listLaravel 8.34 新增： php artisan route:list 获得了新的参数 --except-path，你可以把一些你不想看见的路由过滤掉。 原始PR 自定义Blade指令如果你在不同的 Blade 文件中格式化数据，可以尝试创建自己的 Blade 指令。下面这一段是来自 Laravel Cashier 包的例子： 123&quot;require&quot;: &#123; &quot;laravel/cashier&quot;: &quot;^12.9&quot;,&#125; 123456public function boot()&#123; Blade::directive(&#x27;money&#x27;, function ($expression) &#123; return &quot;&lt;?php echo Laravel\\Cashier\\Cashier::formatAmount($expression, config(&#x27;cashier.currency&#x27;)); ?&gt;&quot;; &#125;);&#125; 1234&lt;div&gt;Price: @money($book-&gt;price)&lt;/div&gt;@if($book-&gt;discount_price) &lt;div&gt;Discounted price: @money($book-&gt;dicount_price)&lt;/div&gt;@endif Artisan命令帮助如果您不确定某些 Artisan 命令的参数，或者您想知道可用的参数，只需键入 php artisan help [command]。 当运行测试时禁用懒加载当运行测试时如果你想排除掉懒加载 你可以禁用掉懒加载 1Model::preventLazyLoading(!$this-&gt;app-&gt;isProduction() &amp;&amp; !$this-&gt;app-&gt;runningUnitTests()); 由 @djgeisi提供 使用两个很好用的辅助函数会带来魔法效果在这个例子中 服务将会被调用并重试。如果仍然失败 将会被报告。但是请求不会失败。(rescue) 12345rescue(function () &#123; retry(5, function () &#123; $this-&gt;service-&gt;callSomething(); &#125;, 200);&#125;); 由 @JuanDMeGon提供 请求参数的默认值以下是我们检测我们使用的per_page值是否存在 否则我们用默认值 12345// Isteand of this$perPage = request()-&gt;per_page ? request()-&gt;per_page : 20;// You can do this$perPage = request(&#x27;per_page&#x27;, 20); 由 @devThaer提供 在路由中直接传入中间件而不是注册它12Route::get(&#x27;posts&#x27;, PostController::class) -&gt;middleware([&#x27;auth&#x27;, CustomMiddleware::class]) 由 @sky_0xs提供 将数组转化成css类123456789101112use Illuminate\\Support\\Arr;$array = [&#x27;p-4&#x27;, &#x27;font-bold&#x27; =&gt; $isActive, &#x27;bg-red&#x27; =&gt; $hasError];$isActive = false;$hasError = true;$classes = Arr::toCssClasses($array);/* * &#x27;p-4 bg-red&#x27; */ 由 @dietsedev提供 Laravel-Cashier中的upcomingInvoice方法您可以显示客户将在下一个计费周期支付的金额。 在Laravel Cashier（Stripe）中有一个“upcomingInvoice”方法来获取即将到来的发票详细信息。 123456Route::get(&#x27;/profile/invoices&#x27;, function (Request $request) &#123; return view(&#x27;/profile/invoices&#x27;, [ &#x27;upcomingInvoice&#x27; =&gt; $request-&gt;user()-&gt;upcomingInvoice(), &#x27;invoices&#x27; =&gt; $request-user()-&gt;invoices(), ]);&#125;); 由 @oliverds_提供 $request-&gt;exists与has1234567// https://example.com?popular$request-&gt;exists(&#x27;popular&#x27;) // true$request-&gt;has(&#x27;popular&#x27;) // false // https://example.com?popular=foo$request-&gt;exists(&#x27;popular&#x27;) // true$request-&gt;has(&#x27;popular&#x27;) // true 由 @coderahuljat提供 返回带变量视图的多种方法1234567891011121314151617181920// First way -&gt;with()return view(&#x27;index&#x27;) -&gt;with(&#x27;projects&#x27;, $projects) -&gt;with(&#x27;tasks&#x27;, $tasks)// Second way - as an arrayreturn view(&#x27;index&#x27;, [ &#x27;projects&#x27; =&gt; $projects, &#x27;tasks&#x27; =&gt; $tasks ]);// Third way - the same as second, but with variable$data = [ &#x27;projects&#x27; =&gt; $projects, &#x27;tasks&#x27; =&gt; $tasks];return view(&#x27;index&#x27;, $data);// Fourth way - the shortest - compact()return view(&#x27;index&#x27;, compact(&#x27;projects&#x27;, &#x27;tasks&#x27;)); 调度标准shell命令我们可以使用scheduled command调度标准shell命令 123456789// app/Console/Kernel.phpclass Kernel extends ConsoleKernel&#123; protected function shedule(Schedule $shedule) &#123; $shedule-&gt;exec(&#x27;node /home/forge/script.js&#x27;)-&gt;daily(); &#125;&#125; 由y @anwar_nairi提供 无需SSL验证的HTTP请求有时候你可能会在本地发送一个无需SSL验证的HTTP请求 可以如下这么干: 1return Http::withoutVerifying()-&gt;post(&#x27;https://example.com&#x27;); 如果想设置一些选项 可以使用 withOptions 1234return Http::withOptions([ &#x27;verify&#x27; =&gt; false, &#x27;allow_redirects&#x27; =&gt; true])-&gt;post(&#x27;https://example.com&#x27;); 由 @raditzfarhan提供 未经验证的HTTP客户端请求有时，您可能希望在本地环境中发送HTTP请求而不验证SSL，您可以这样做： 1return Http::withoutVerifying()-&gt;post(&#x27;https://example.com&#x27;); 如果要设置多个选项，可以使用withOptions。 1234return Http::withOptions([ &#x27;verify&#x27; =&gt; false, &#x27;allow_redirects&#x27; =&gt; true])-&gt;post(&#x27;https://example.com&#x27;); Tip given by @raditzfarhan 不断言任何内容的测试不断言任何内容的测试，只需启动一些可能引发或不引发异常的内容 12345678class MigrationsTest extends TestCase&#123; public function test_successful_foreign_key_in_migrations() &#123; // We just test if the migrations succeeds or throws an exception $this-&gt;expectNotToPerformAssertions(); &#125;&#125; Str的mask方法Laravel 8.69发布了“Str:：mask（）”方法，该方法使用重复字符屏蔽字符串的一部分. 1234567891011121314class PasswordResetLinkController extends Controller&#123; public function sendResetLinkResponse(Request $request) &#123; $userEmail = User::where(&#x27;email&#x27;, $request-&gt;email)-&gt;value(&#x27;email&#x27;); // username@domain.com $maskedEmail = Str::mask($userEmail, &#x27;*&#x27;, 4); // user*************** // If needed, you provide a negative number as the third argument to the mask method, // which will instruct the method to begin masking at the given distance from the end of the string $maskedEmail = Str::mask($userEmail, &#x27;*&#x27;, -16, 6); // use******domain.com &#125;&#125; @Teacoders 扩展Laravel类在许多内置的Laravel类上有一个名为macro的方法。例如，集合、Str、Arr、请求、缓存、文件等 您可以在这些类上定义自己的方法，如下所示： 12345Str::macro(&#x27;lowerSnake&#x27;, function (string $str) &#123; return Str::lower(Str::snake($str));&#125;);// Will return: &quot;my-string&quot;Str::lowerSnake(&#x27;MyString&#x27;); Tip given by @mmartin_joo Can特性Laravel v8.70中, 你可以链式调用can() 方法替代 middleware(&#39;can:..&#39;) 123456789// instead ofRoute::get(&#x27;users/&#123;user&#125;/edit&#x27;, function (User $user) &#123; ...&#125;)-&gt;middleware(&#x27;can:edit,user&#x27;);// you can do thisRoute::get(&#x27;users/&#123;user&#125;/edit&#x27;, function (User $user) &#123; ...&#125;)-&gt;can(&#x27;edit&#x27; &#x27;user&#x27;);// PS: you must write UserPolicy to be able to do this in both cases @sky_0xs 临时下载url您可以使用云存储资源的临时下载URL来防止不必要的访问。例如，当一个用户想要下载一个文件时，我们重定向到一个s3资源，但是URL在5秒内过期。 1234567public function download(File $file)&#123; // Initiate file download by redirecting to a temporary s3 URL that expires in 5 seconds return redirect()-&gt;to( Storage::disk(&#x27;s3&#x27;)-&gt;temporaryUrl($file-&gt;name, now()-&gt;addSeconds(5)) );&#125; @Philo01 处理深度嵌套数组处理深度嵌套数组可能会导致缺少键&#x2F;值异常。幸运的是，Laravel的data_get（）助手使这一点很容易避免。它还支持深度嵌套的对象 深度嵌套的数组可能缺少所需的属性，这是一场噩梦 在下面的示例中，如果缺少’request’，’user’或’name’，则会出现错误。 1$value = $payload[&#x27;request&#x27;][&#x27;user&#x27;][&#x27;name&#x27;] Instead, use the data_get() helper to access a deeply-nested array item using dot notation. 1$value = data_get($payload, &#x27;request.user.name&#x27;); We can also avoid any errors caused by missing properties by supplying a default value. 1$value = data_get($payload, &#x27;request.user.name&#x27;, &#x27;John&#x27;); @mattkingshott 自定义异常的呈现方式1234567891011121314151617abstract class BaseException extends Exception&#123; public function render(Request $request) &#123; if ($request-&gt;expectsJson()) &#123; return response()-&gt;json([ &#x27;meta&#x27; =&gt; [ &#x27;valid&#x27; =&gt; false, &#x27;status&#x27; =&gt; static::ID, &#x27;message&#x27; =&gt; $this-&gt;getMessage(), ], ], $this-&gt;getCode()); &#125; return response()-&gt;view(&#x27;errors.&#x27; . $this-&gt;getCode(), [&#x27;exception&#x27; =&gt; $this], $this-&gt;getCode()); &#125;&#125; 123456class LicenseExpiredException extends BaseException&#123; public const ID = &#x27;EXPIRED&#x27;; protected $code = 401; protected $message = &#x27;Given license has expired.&#x27;&#125; @Philo01 tap助手函数tap助手是在对对象调用方法后删除单独的return语句的好方法。使事物变得美好和干净. 12345// without tap$user-&gt;update([&#x27;name&#x27; =&gt; &#x27;John Doe&#x27;]);return $user;// with tap()return tap($user)-&gt;update([&#x27;name&#x27; =&gt; &#x27;John Doe&#x27;]); Tip given by @mattkingshott 重置所有剩余的时间单位您可以在DateTime::createFromFormat方法中插入感叹号以重置所有剩余的时间单位 123456// 2021-10-12 21:48:07.0DateTime::createFromFormat(&#x27;Y-m-d&#x27;, &#x27;2021-10-12&#x27;);// 2021-10-12 00:00:00.0DateTime::createFromFormat(&#x27;!Y-m-d&#x27;, &#x27;2021-10-12&#x27;);2021-10-12 21:00:00.0DateTime::createFromFormat(&#x27;!Y-m-d H&#x27;, &#x27;2021-10-12&#x27;); Tip given by @SteveTheBauman 控制台内核中的计划命令问题可以自动通过电子邮件发送其输出您知道吗，如果出现问题，您在控制台内核中调度的任何命令都可以自动通过电子邮件发送其输出 1234$schedule -&gt;command(PruneOrganizationsCOmmand::class) -&gt;hourly() -&gt;emailOutputOnFailure(config(&#x27;mail.support&#x27;)); @mattkingshott 使用GET参数构造自定义筛选查询时要小心12345678910111213if (request()-&gt;has(&#x27;since&#x27;)) &#123; // example.org/?since= // fails with illegal operator and value combination $query-&gt;whereDate(&#x27;created_at&#x27;, &#x27;&lt;=&#x27;, request(&#x27;since&#x27;));&#125;if (request()-&gt;input(&#x27;name&#x27;)) &#123; // example.org/?name=0 // fails to apply query filter because evaluates to false $query-&gt;where(&#x27;name&#x27;, request(&#x27;name&#x27;));&#125;if (request()-&gt;filled(&#x27;key&#x27;)) &#123; // correct way to check if get parameter has value&#125; @mc0de 清理你臃肿的路由文件清掉臃肿的路由文件，并将其拆分以保持组织有序 1234567891011121314151617181920212223242526class RouteServiceProvider extends ServiceProvider&#123; public function boot() &#123; $this-&gt;routes(function () &#123; Route::prefix(&#x27;api/v1&#x27;) -&gt;middleware(&#x27;api&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/api.php&#x27;)); Route::prefix(&#x27;webhooks&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/webhooks.php&#x27;)); Route::middleware(&#x27;web&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/web.php&#x27;)); if ($this-&gt;app-&gt;environment(&#x27;local&#x27;)) &#123; Route::middleware(&#x27;web&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/local.php&#x27;)); &#125; &#125;); &#125;&#125; @Philo01 自定义邮件日志存储位置你可以自定义日志存储位置. 通过设置环境变量如下 12MAIL_MAILER=logMAIL_LOG_CHANNEL=mail 也可以设置日志渠道 12345&#x27;mail&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;single&#x27;, &#x27;path&#x27; =&gt; storage_path(&#x27;logs/mails.log&#x27;), &#x27;level&#x27; =&gt; env(&#x27;LOG_LEVEL&#x27;, &#x27;debug&#x27;),], @mmartin_joo markdown简单创建Laravel提供了一个接口来转换HTML中的即时标记，而无需安装新的composer软件包。 1$html = Str::markdown(&#x27;# Changelogfy&#x27;) Output: 1&lt;h1&gt;Changelogfy&lt;/h1&gt; @paulocastellano 给中间件传参数您可以通过在值后面附加“:”向中间件传递特定路由的参数。例如，我使用一个中间件基于路由实施不同的身份验证方法。 123Route::get(&#x27;...&#x27;)-&gt;middleware(&#x27;auth.license&#x27;);Route::get(&#x27;...&#x27;)-&gt;middleware(&#x27;auth.license:bearer&#x27;);Route::get(&#x27;...&#x27;)-&gt;middleware(&#x27;auth.license:basic&#x27;); 12345678910111213class VerifyLicense&#123; public function handle(Request $request, Closure $next, $type = null) &#123; $licenseKey = match ($type) &#123; &#x27;basic&#x27; =&gt; $request-&gt;getPassword(), &#x27;bearer&#x27; =&gt; $request-&gt;bearerToken(), default =&gt; $request-&gt;get(&#x27;key&#x27;) &#125;; // Verify license and return response based on the authentication type &#125;&#125; @Philo01 获取并删除session如果您需要从Laravel会话中获取一些东西，并立即忘记它，考虑使用Session()-&gt;pull(value)。它为您完成了这两个步骤。 123456// Before$path = session()-&gt;get(&#x27;before-github-redirect&#x27;, &#x27;/components&#x27;);session()-&gt;forget(&#x27;before-github-redirect&#x27;);return redirect($path);// Afterreturn redirect(session()-&gt;pull(&#x27;before-github-redirect&#x27;, &#x27;/components&#x27;)) @jasonlbeggs提供 request的date方法Laravel v8.77: $request-&gt;date() 方法 现在您不需要手动调用Carbon，您可以执行以下操作：$post-&gt;publish_at=$request-&gt;date（&#39;publish_at&#39;）-&gt;&gt;addHour()-&gt;startOfHour()Link to full pr by @DarkGhostHunter 使用分页时请使用through而不是map当您想要映射分页数据并只返回字段的子集时，请使用through而不是map。map会打断分页对象并更改其标识。而，through作用于分页数据本身 12345678910// Don&#x27;t: Mapping paginated data$employees = Employee::paginate(10)-&gt;map(fn ($employee) =&gt; [ &#x27;id&#x27; =&gt; $employee-&gt;id, &#x27;name&#x27; =&gt; $employee-&gt;name])// Do: Mapping paginated data$employees = Employee::paginate(10)-&gt;through(fn ($employee) =&gt; [ &#x27;id&#x27; =&gt; $employee-&gt;id, &#x27;name&#x27; =&gt; $employee-&gt;name]) @bhaidar","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"view","slug":"laravel/Views","date":"2024-03-07T09:34:16.875Z","updated":"2024-03-07T10:02:37.713Z","comments":true,"path":"2024/03/07/laravel/Views/","link":"","permalink":"http://example.com/2024/03/07/laravel/Views/","excerpt":"","text":"视图 foreach 语句中的 $loop 变量 视图是否存在 错误代码视图页面 脱离控制器的视图 Blade @auth 指令 Blade 视图中的二级 $loop 变量 创建你自己的 Blade 指令 视图指令IncludeIf IncludeWhen IncludeFirst 使用Laravel Blade-X 变量绑定节省更多空间 Blade 组件属性 Blade类型提示 组件语法提示 自动高亮导航链接 简化循环 整理blade视图的简单方法 foreach 语句中的 $loop 变量在 foreach 循环中，使用 $loop 变量来查看当前是否是第一次 &#x2F; 最后一次循环。 1234567891011@foreach ($users as $user) @if ($loop-&gt;first) This is the first iteration. @endif @if ($loop-&gt;last) This is the last iteration. @endif &lt;p&gt;This is user &#123;&#123; $user-&gt;id &#125;&#125;&lt;/p&gt;@endforeach 同样也有诸如 $loop-&gt;iteration 或 $loop-&gt;count 等属性。可以在 官方文档中查看更多相关内容。 视图是否存在你可以在视图实际加载之前确认该视图文件是否存在。 123if (view()-&gt;exists(&#x27;custom.page&#x27;)) &#123; // Load the view&#125; 你甚至可以使用一个数组来加载视图，这样只有第一个视图文件确实存在的视图会被加载。 1return view()-&gt;first([&#x27;custom.dashboard&#x27;, &#x27;dashboard&#x27;], $data); 错误代码视图页面如果你想为一些特殊的 HTTP 返回码建立特定的错误页面，比如 500 —— 只需要使用该码值创建视图文件，比如 resources/views/errors/500.blade.php ，或者是 403.blade.php 等等，这些视图会在对应的错误码出现时自动被加载。 脱离控制器的视图如果你想让一个路由仅仅显示某个视图，不需要创建控制器，只需要使用 Route::view() 方法即可。 123456789101112// Instead of thisRoute::get(&#x27;about&#x27;, &#x27;TextsController@about&#x27;);// And thisclass TextsController extends Controller&#123; public function about() &#123; return view(&#x27;texts.about&#x27;); &#125;&#125;// Do thisRoute::view(&#x27;about&#x27;, &#x27;texts.about&#x27;); Blade @auth 指令不需要使用 if 来检查用户是否登录，使用 @auth 指令即可。 比较典型的方式是： 123@if(auth()-&gt;user()) // The user is authenticated.@endif 更短的用法： 123@auth // The user is authenticated.@endauth 与 @auth 相对的是 @guest 指令： 123@guest // The user is not authenticated.@endguest Blade 视图中的二级 $loop 变量你甚至可以在 Blade 视图的二级 foreach 循环中使用 $loop 变量来表示外层的循环变量。 1234567@foreach ($users as $user) @foreach ($user-&gt;posts as $post) @if ($loop-&gt;parent-&gt;first) This is first iteration of the parent loop. @endif @endforeach@endforeach 创建你自己的 Blade 指令你只需要在 app/Providers/AppServiceProvider.php 中添加你自己的方法。举个例子，如果你需要将 &lt;br&gt; 标签替换为换行： 1&lt;textarea&gt;@br2nl($post-&gt;post_text)&lt;/textarea&gt; 然后将这个指令添加到 AppServiceProvider 的 boot() 方法中： 123456public function boot()&#123; Blade::directive(&#x27;br2nl&#x27;, function ($string) &#123; return &quot;&lt;?php echo preg_replace(&#x27;/\\&lt;br(\\s*)?\\/?\\&gt;/i&#x27;, \\&quot;\\n\\&quot;, $string); ?&gt;&quot;; &#125;);&#125; 视图指令IncludeIf IncludeWhen IncludeFirst如果你不确定 Blade 文件是否存在，你可以使用这些条件指令。仅当 Blade 文件存在时载入 header： 1@includeIf(&#x27;partials.header&#x27;) 仅当用户的 role_id &#x3D;&#x3D; 1 的时候载入 header： 1@includeWhen(auth()-&gt;user()-&gt;role_id == 1, &#x27;partials.header&#x27;) 尝试加载 adminlte.header ，如果不存在，则加载 default.header： 1@includeFirst(&#x27;adminlte.header&#x27;, &#x27;default.header&#x27;) 使用Laravel Blade-X 变量绑定节省更多空间12345678// Using include, the old way@include(&quot;components.post&quot;, [&quot;title&quot; =&gt; $post-&gt;title])// Using Blade-X&lt;x-post link=&quot;&#123;&#123; $post-&gt;title &#125;&#125;&quot; /&gt;// Using Blade-X variable binding&lt;x-post :link=&quot;$post-&gt;title&quot; /&gt; 由 @anwar_nairi提供 Blade 组件属性12345678910111213141516// button.blade.php@props([&#x27;rounded&#x27; =&gt; false])&lt;button &#123;&#123; $attributes-&gt;class([ &#x27;bg-red-100 text-red-800&#x27;, &#x27;rounded&#x27; =&gt; $rounded ]) &#125;&#125;&gt; &#123;&#123; $slot &#125;&#125;&lt;/button&gt;// view.blade.php// Non-rounded:&lt;x-button&gt;Submit&lt;/x-button&gt;// Rounded:&lt;x-button rounded&gt;Submit&lt;/x-button&gt; 由 @godismyjudge95提供 Blade类型提示1234567@php /* @var App\\Models\\User $user */@endphp&lt;div&gt; // your ide will typehint the property for you &#123;&#123;$user-&gt;email&#125;&#125;&lt;/div&gt; 由 @freekmurze提供 组件语法提示在组件参数之前传入 : 你可以直接传入变量而不需要使用 &#123;&#123;&#125;&#125;表达式 123&lt;x-navbar title=&quot;&#123;&#123; $title &#125;&#125;&quot;/&gt;// you can do instead&lt;x-navbar :title=&quot;$title&quot;/&gt; 由 @sky_0xs提供 自动高亮导航链接当精确的URL匹配或传递路径或路由名称模式时，自动突出显示导航链接 带有请求和CSS类助手的 blade 组件使显示活动&#x2F;非活动状态变得非常简单。 12345678910111213141516171819202122232425262728293031323334class NavLink extends Component&#123; public function __construct($href, $active = null) &#123; $this-&gt;href = $href; $this-&gt;active = $active ?? $href; &#125; public function render(): View &#123; $classes = [&#x27;font-medium&#x27;, &#x27;py-2&#x27;, &#x27;text-primary&#x27; =&gt; $this-&gt;isActive()]; return view(&#x27;components.nav-link&#x27;, [ &#x27;class&#x27; =&gt; Arr::toCssClasses($classes); ]); &#125; protected function isActive(): bool &#123; if (is_bool($this-&gt;active)) &#123; return $this-&gt;active; &#125; if (request()-&gt;is($this-&gt;active)) &#123; return true; &#125; if (request()-&gt;fullUrlIs($this-&gt;active)) &#123; return true; &#125; return request()-&gt;routeIs($this-&gt;active); &#125;&#125; 123&lt;a href=&quot;&#123;&#123; $href &#125;&#125;&quot; &#123;&#123; $attributes-&gt;class($class) &#125;&#125;&gt; &#123;&#123; $slot &#125;&#125;&lt;/a&gt; 1234&lt;x-nav-link :href=&quot;route(&#x27;projects.index&#x27;)&quot;&gt;Projects&lt;/x-nav-link&gt;&lt;x-nav-link :href=&quot;route(&#x27;projects.index&#x27;)&quot; active=&quot;projects.*&quot;&gt;Projects&lt;/x-nav-link&gt;&lt;x-nav-link :href=&quot;route(&#x27;projects.index&#x27;)&quot; active=&quot;projects/*&quot;&gt;Projects&lt;/x-nav-link&gt;&lt;x-nav-link :href=&quot;route(&#x27;projects.index&#x27;)&quot; :active=&quot;$tab = &#x27;projects&#x27;&quot;&gt;Projects&lt;/x-nav-link&gt; @mpskovvang提供 简化循环你知道Blade@each指令可以帮助清理模板中的循环吗？ 123456789// good@foreach($item in $items) &lt;div&gt; &lt;p&gt;Name: &#123;&#123; $item-&gt;name &#125;&#125; &lt;p&gt;Price: &#123;&#123; $item-&gt;price &#125;&#125; &lt;/div&gt;@endforeach// better (HTML extracted into partial)@each(&#x27;partials.item&#x27;, $items, &#x27;item&#x27;) @kirschbaum_dev提供 整理blade视图的简单方法整理刀片视图的简单方法 使用forelse·，而不是嵌套在if语句中的foreach&#96; 123456789101112131415161718&lt;!-- if/loop combination --&gt;@if ($orders-&gt;count()) @foreach($orders as $order) &lt;div&gt; &#123;&#123; $order-&gt;id &#125;&#125; &lt;/div&gt; @endforeach@else &lt;p&gt;You haven&#x27;t placed any orders yet.&lt;/p&gt;@endif&lt;!-- Forelse alternative --&gt;@forelse($orders as $order) &lt;div&gt; &#123;&#123; $order-&gt;id &#125;&#125; &lt;/div&gt;@empty &lt;p&gt;You haven&#x27;t placed any orders yet.&lt;/p&gt;@endforelse 由 [@alexjgarrett]提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"route","slug":"laravel/Routing","date":"2024-03-07T09:34:16.875Z","updated":"2024-03-07T10:02:32.346Z","comments":true,"path":"2024/03/07/laravel/Routing/","link":"","permalink":"http://example.com/2024/03/07/laravel/Routing/","excerpt":"","text":"路由 分组中的分组 通配符子域名 Auth::routes调用之后是什么 路由模型绑定-你可以定义一个Key 快速从路由导航到控制器 备选路由-当没有匹配到任何路由时 使用正则进行路由参数验证 限流-全局配置与按用户配置 路由中的URL参数 按文件为路由分类 翻译资源中的动词 自定义资源路由名称 可读性更强的路由列表 预加载 本地化资源URI 资源控制器命名 更简单地高亮你的导航栏 使用route()辅助函数生成绝对路径 为你的每个模型重写路由绑定解析器 如果你需要一个公共URL但是你想让他们更安全 在中间件中使用Gate 简单路由-使用箭头函数 路由视图 分组中的分组在路由中，你可以在分组中创建分组，来实现仅仅为父分组中的某些路由分配中间件。 12345678Route::group([&#x27;prefix&#x27; =&gt; &#x27;account&#x27;, &#x27;as&#x27; =&gt; &#x27;account.&#x27;], function() &#123; Route::get(&#x27;login&#x27;, &#x27;AccountController@login&#x27;); Route::get(&#x27;register&#x27;, &#x27;AccountController@register&#x27;); Route::group([&#x27;middleware&#x27; =&gt; &#x27;auth&#x27;], function() &#123; Route::get(&#x27;edit&#x27;, &#x27;AccountController@edit&#x27;); &#125;);&#125;); 通配符子域名你可以在分组中定义变量，来创建动态子域名分组，然后将这个变量传递给每一个子路由。 12345Route::domain(&#x27;&#123;username&#125;.workspace.com&#x27;)-&gt;group(function () &#123; Route::get(&#x27;user/&#123;id&#125;&#x27;, function ($username, $id) &#123; // &#125;);&#125;); routes调用之后是什么若你使用 Laravel UI package, 你可能想知道Auth::routes()定义之后真正的路由是什么? 查看 /vendor/laravel/ui/src/AuthRouteMethods.php. 1234567891011121314151617181920212223242526public function auth()&#123; return function ($options = []) &#123; // Authentication Routes... $this-&gt;get(&#x27;login&#x27;, &#x27;Auth\\LoginController@showLoginForm&#x27;)-&gt;name(&#x27;login&#x27;); $this-&gt;post(&#x27;login&#x27;, &#x27;Auth\\LoginController@login&#x27;); $this-&gt;post(&#x27;logout&#x27;, &#x27;Auth\\LoginController@logout&#x27;)-&gt;name(&#x27;logout&#x27;); // Registration Routes... if ($options[&#x27;register&#x27;] ?? true) &#123; $this-&gt;get(&#x27;register&#x27;, &#x27;Auth\\RegisterController@showRegistrationForm&#x27;)-&gt;name(&#x27;register&#x27;); $this-&gt;post(&#x27;register&#x27;, &#x27;Auth\\RegisterController@register&#x27;); &#125; // Password Reset Routes... if ($options[&#x27;reset&#x27;] ?? true) &#123; $this-&gt;resetPassword(); &#125; // Password Confirmation Routes... if ($options[&#x27;confirm&#x27;] ?? class_exists($this-&gt;prependGroupNamespace(&#x27;Auth\\ConfirmPasswordController&#x27;))) &#123; $this-&gt;confirmPassword(); &#125; // Email Verification Routes... if ($options[&#x27;verify&#x27;] ?? false) &#123; $this-&gt;emailVerification(); &#125; &#125;;&#125; 默认调用: 1Auth::routes(); // no parameters 但是你可以提供参数来启用或禁用真正的路由 But you can provide parameters to enable o disable certain routes: 12345678Auth::routes([ &#x27;login&#x27; =&gt; true, &#x27;logout&#x27; =&gt; true, &#x27;register&#x27; =&gt; true, &#x27;reset&#x27; =&gt; true, // for resetting passwords &#x27;confirm&#x27; =&gt; false, // for additional password confirmations &#x27;verify&#x27; =&gt; false, // for email verification]); 由 suggestion by MimisK13提供 路由模型绑定-你可以定义一个Key你可以像 Route::get(&#39;api/users/&#123;user&#125;&#39;, function (App\\User $user) &#123; … &#125; 这样来进行路由模型绑定，但不仅仅是 ID 字段，如果你想让 {user} 是 username，你可以把它放在模型中： 123public function getRouteKeyName() &#123; return &#x27;username&#x27;;&#125; 快速从路由导航到控制器在 Laravel 8 之前，这件事情是可选的。在 Laravel 8 中这将成为路由的标准语法 不用这么写: 1Route::get(&#x27;page&#x27;, &#x27;PageController@action&#x27;); 你可以将控制器标识为 class 类名: 1Route::get(&#x27;page&#x27;, [\\App\\Http\\Controllers\\PageController::class, &#x27;action&#x27;]); 这样，你就可以在 PhpStorm中点击 PageController 来跳转到控制器定义，而不是手动去搜索它 或者你想要让路由的定义更简洁，你可以在路由文件的开始提前引入控制器的类。 1234use App\\Http\\Controllers\\PageController;// Then:Route::get(&#x27;page&#x27;, [PageController::class, &#x27;action&#x27;]); 备选路由-当没有匹配到任何路由时如果你想为未找到的路由指定其它逻辑，而不是直接显示 404 页面，你可以在路由文件的最后为其创建一个特殊的路由。 123456789Route::group([&#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;], &#x27;prefix&#x27; =&gt; &#x27;admin&#x27;, &#x27;as&#x27; =&gt; &#x27;admin.&#x27;], function () &#123; Route::get(&#x27;/home&#x27;, &#x27;HomeController@index&#x27;); Route::resource(&#x27;tasks&#x27;, &#x27;Admin\\TasksController&#x27;);&#125;);// Some more routes....Route::fallback(function() &#123; return &#x27;Hm, why did you land here somehow?&#x27;;&#125;); 使用正则进行路由参数验证我们可以在路由中使用 where参数 来直接验证参数。一个典型的例子是，当使用语言区域的参数来作为路由前缀时，像是 fr/blog 和 en/article/333 等，这时我们如何来确保这两个首字母没有被用在其他语言呢？ routes/web.php: 1234567Route::group([ &#x27;prefix&#x27; =&gt; &#x27;&#123;locale&#125;&#x27;, &#x27;where&#x27; =&gt; [&#x27;locale&#x27; =&gt; &#x27;[a-zA-Z]&#123;2&#125;&#x27;]], function () &#123; Route::get(&#x27;/&#x27;, &#x27;HomeController@index&#x27;); Route::get(&#x27;article/&#123;id&#125;&#x27;, &#x27;ArticleController@show&#x27;);&#125;); 限流-全局配置与按用户配置你可以使用 throttle:60,1 来限制一些 URL 在每分钟内最多被访问 60 次。 12345Route::middleware(&#x27;auth:api&#x27;, &#x27;throttle:60,1&#x27;)-&gt;group(function () &#123; Route::get(&#x27;/user&#x27;, function () &#123; // &#125;);&#125;); 另外，你也可以为公开请求和登录用户分别配置： 1234// maximum of 10 requests for guests, 60 for authenticated usersRoute::middleware(&#x27;throttle:10|60,1&#x27;)-&gt;group(function () &#123; //&#125;); 此外，你也可以使用数据库字段 users.rate_limit 为一些特殊用户设定此值。 12345Route::middleware(&#x27;auth:api&#x27;, &#x27;throttle:rate_limit,1&#x27;)-&gt;group(function () &#123; Route::get(&#x27;/user&#x27;, function () &#123; // &#125;);&#125;); 路由中的URL参数如果你在路由中使用数组传入了其它参数，这些键 &#x2F; 值将会自动配对并且带入 URL 查询参数中。 12345Route::get(&#x27;user/&#123;id&#125;/profile&#x27;, function ($id) &#123; //&#125;)-&gt;name(&#x27;profile&#x27;);$url = route(&#x27;profile&#x27;, [&#x27;id&#x27; =&gt; 1, &#x27;photos&#x27; =&gt; &#x27;yes&#x27;]); // Result: /user/1/profile?photos=yes 按文件为路由分类如果你有一组与某些功能相关的路由，你可以将它们放在一个特殊的文件 routes/XXXXX.php 中，然后在 routes/web.php 中使用 include 引入它。&#96; Taylor Otwell 在 Laravel Breeze 中的例子：routes/auth.php 123456789Route::get(&#x27;/&#x27;, function () &#123; return view(&#x27;welcome&#x27;);&#125;);Route::get(&#x27;/dashboard&#x27;, function () &#123; return view(&#x27;dashboard&#x27;);&#125;)-&gt;middleware([&#x27;auth&#x27;])-&gt;name(&#x27;dashboard&#x27;);require __DIR__.&#x27;/auth.php&#x27;; 然后，在 routes/auth.php 中: 1234567891011121314use App\\Http\\Controllers\\Auth\\AuthenticatedSessionController;use App\\Http\\Controllers\\Auth\\RegisteredUserController;// ... more controllersuse Illuminate\\Support\\Facades\\Route;Route::get(&#x27;/register&#x27;, [RegisteredUserController::class, &#x27;create&#x27;]) -&gt;middleware(&#x27;guest&#x27;) -&gt;name(&#x27;register&#x27;);Route::post(&#x27;/register&#x27;, [RegisteredUserController::class, &#x27;store&#x27;]) -&gt;middleware(&#x27;guest&#x27;);// ... A dozen more routes 但是，你应该只在路由都各自具有相同的前缀 &#x2F; 中间件配置时使用 include() 来引入路由，否则，更好的选择是将他们分类在 app/Providers/RouteServiceProvider 中。 1234567891011121314151617public function boot()&#123; $this-&gt;configureRateLimiting(); $this-&gt;routes(function () &#123; Route::prefix(&#x27;api&#x27;) -&gt;middleware(&#x27;api&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/api.php&#x27;)); Route::middleware(&#x27;web&#x27;) -&gt;namespace($this-&gt;namespace) -&gt;group(base_path(&#x27;routes/web.php&#x27;)); // ... Your routes file listed next here &#125;);&#125; 翻译资源中的动词当你使用了资源控制器，但希望变更 URL 谓词以适应非英语语言环境下的 SEO ，以在路由中用 /crear 替换 /create，你可以使用 App\\Providers\\RouteServiceProvider 中的 Route::resourceVerbs() 配置。 123456789public function boot()&#123; Route::resourceVerbs([ &#x27;create&#x27; =&gt; &#x27;crear&#x27;, &#x27;edit&#x27; =&gt; &#x27;editar&#x27;, ]); // ...&#125; 自定义资源路由名称当使用资源路由时，你可以在 routes/web.php 中指定 -&gt;names() 参数，这样一来，在整个 Laravel 项目中，浏览器中的 URL 前缀和路由名称前缀可能会不同。 1Route::resource(&#x27;p&#x27;, ProductController::class)-&gt;names(&#x27;products&#x27;); 这行代码将会生成像 /p, /p/&#123;id&#125;, /p/&#123;id&#125;/edit 这样的路由，但是你可以在代码中使用 route(&#39;products.index&#39;), route(&#39;products.create&#39;) 等方式来调用它们。 可读性更强的路由列表你有没有运行过 php artisan route:list ，然后发现这个列表又长，可读性又很差。另一个方法是：php artisan route:list --compact这样只会输出 3 列，而非 6 列：只展示方法名、 URI 和方法 123456789101112131415161718192021+----------+---------------------------------+-------------------------------------------------------------------------+| Method | URI | Action |+----------+---------------------------------+-------------------------------------------------------------------------+| GET|HEAD | / | Closure || GET|HEAD | api/user | Closure || POST | confirm-password | App\\Http\\Controllers\\Auth\\ConfirmablePasswordController@store || GET|HEAD | confirm-password | App\\Http\\Controllers\\Auth\\ConfirmablePasswordController@show || GET|HEAD | dashboard | Closure || POST | email/verification-notification | App\\Http\\Controllers\\Auth\\EmailVerificationNotificationController@store || POST | forgot-password | App\\Http\\Controllers\\Auth\\PasswordResetLinkController@store || GET|HEAD | forgot-password | App\\Http\\Controllers\\Auth\\PasswordResetLinkController@create || POST | login | App\\Http\\Controllers\\Auth\\AuthenticatedSessionController@store || GET|HEAD | login | App\\Http\\Controllers\\Auth\\AuthenticatedSessionController@create || POST | logout | App\\Http\\Controllers\\Auth\\AuthenticatedSessionController@destroy || POST | register | App\\Http\\Controllers\\Auth\\RegisteredUserController@store || GET|HEAD | register | App\\Http\\Controllers\\Auth\\RegisteredUserController@create || POST | reset-password | App\\Http\\Controllers\\Auth\\NewPasswordController@store || GET|HEAD | reset-password/&#123;token&#125; | App\\Http\\Controllers\\Auth\\NewPasswordController@create || GET|HEAD | verify-email | App\\Http\\Controllers\\Auth\\EmailVerificationPromptController@__invoke || GET|HEAD | verify-email/&#123;id&#125;/&#123;hash&#125; | App\\Http\\Controllers\\Auth\\VerifyEmailController@__invoke |+----------+---------------------------------+-------------------------------------------------------------------------+ 你还可以特别地指定所需要的列： php artisan route:list --columns=Method,URI,Name 123456789101112131415161718192021+----------+---------------------------------+---------------------+| Method | URI | Name |+----------+---------------------------------+---------------------+| GET|HEAD | / | || GET|HEAD | api/user | || POST | confirm-password | || GET|HEAD | confirm-password | password.confirm || GET|HEAD | dashboard | dashboard || POST | email/verification-notification | verification.send || POST | forgot-password | password.email || GET|HEAD | forgot-password | password.request || POST | login | || GET|HEAD | login | login || POST | logout | logout || POST | register | || GET|HEAD | register | register || POST | reset-password | password.update || GET|HEAD | reset-password/&#123;token&#125; | password.reset || GET|HEAD | verify-email | verification.notice || GET|HEAD | verify-email/&#123;id&#125;/&#123;hash&#125; | verification.verify |+----------+---------------------------------+---------------------+ 预加载如果你使用了路由模型绑定，并且你认为不会在绑定关系中使用预加载，请你再想一想。所以当你用了这样的路由模型绑定: 123public function show(Product $product) &#123; //&#125; 但是你有一个从属关系，这时候就不能使用 $product-&gt;with(&#39;category&#39;) 预加载了吗？你当然可以，使用 -&gt;load() 来加载关系 But you have a belongsTo relationship, and cannot use $product-&gt;with(‘category’) eager loading?You actually can! Load the relationship with -&gt;load() 1234public function show(Product $product) &#123; $product-&gt;load(&#x27;category&#x27;); //&#125; 本地化资源URI如果你使用了资源控制器，但是想要将 URL 谓词变为非英语形式的，比如你想要西班牙语的 /crear 而不是 /create ，你可以使用 Route::resourceVerbs() 方法来配置。 12345678public function boot()&#123; Route::resourceVerbs([ &#x27;create&#x27; =&gt; &#x27;crear&#x27;, &#x27;edit&#x27; =&gt; &#x27;editar&#x27;, ]); //&#125; 资源控制器命名在资源控制器中，你可以在 routes/web.php 中指定 -&gt;names() 参数，这样 URL 前缀与路由前缀可能会不同.这样会生成诸如 /p, /p/&#123;id&#125;, /p/&#123;id&#125;/edit 等等，但是你可以这样调用它们： route(&#39;products.index)route(&#39;products.create)等等 1Route::resource(&#x27;p&#x27;, \\App\\Http\\Controllers\\ProductController::class)-&gt;names(&#x27;products&#x27;); 更简单地高亮你的导航栏使用Route::is(&#39;route-name&#39;)来更简单的高亮你的导航栏 12345678&lt;ul&gt; &lt;li @if(Route::is(&#x27;home&#x27;)) class=&quot;active&quot; @endif&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li @if(Route::is(&#x27;contact-us&#x27;)) class=&quot;active&quot; @endif&gt; &lt;a href=&quot;/contact-us&quot;&gt;Contact us&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 由 @anwar_nairi提供 使用route辅助函数生成绝对路径12345route(&#x27;page.show&#x27;, $page-&gt;id);// http://laravel.test/pages/1route(&#x27;page.show&#x27;, $page-&gt;id, false);// /pages/1 由 @oliverds_提供 为你的每个模型重写路由绑定解析器你可以为你的所有模型重写路由绑定解析器。在这个例子里，我们没有对URL 中的 @ 符号做任何处理，所以 用&#96;&#96;resolveRouteBinding 我可以移除@符号 然后解析模型 12345678910111213// RouteRoute::get(&#x27;&#123;product:slug&#125;&#x27;, Controller::class);// Requesthttps://nodejs.pub/@unlock/hello-world// Product Modelpublic function resolveRouteBinding($value, $field = null)&#123; $value = str_replace(&#x27;@&#x27;, &#x27;&#x27;, $value); return parent::resolveRouteBinding($value, $field);&#125; 由 @Philo01提供 如果你需要一个公共URL但是你想让他们更安全如果你需要一个公共URL但是你想让他们更安全，使用 Laravel signed URL 12345678910111213141516171819202122class AccountController extends Controller&#123; public function destroy(Request $request) &#123; $confirmDeleteUrl = URL::signedRoute(&#x27;confirm-destroy&#x27;, [ $user =&gt; $request-&gt;user() ]); // Send link by email... &#125; public function confirmDestroy(Request $request, User $user) &#123; if (! $request-&gt;hasValidSignature()) &#123; abort(403); &#125; // User confirmed by clikcing on the email $user-&gt;delete(); return redirect()-&gt;route(&#x27;home&#x27;); &#125;&#125; 由 @anwar_nairi提供 在中间件中使用Gate你可以在中间件中使用在 App\\Providers\\AuthServiceProvider设置的Gate 怎么做呢?你可以在路由中添加can:和必要gate的名字 123Route::put(&#x27;/post/&#123;post&#125;&#x27;, function (Post $post) &#123; // The current user may update the post...&#125;)-&gt;middleware(&#x27;can:update,post&#x27;); 简单路由-使用箭头函数在路由中你可以使用PHP的箭头函数 而不需要用匿名函数。 要做到这一点 你可以使用 fn() =&gt; 这样看起来更简单。 123456// Instead ofRoute::get(&#x27;/example&#x27;, function () &#123; return User::all();&#125;);// You canRoute::get(&#x27;/example&#x27;, fn () =&gt; User::all()); 路由视图使用Route::view($uri , $bladePage)直接返回view 而不需要控制器方法 12//this will return home.blade.php viewRoute::view(&#x27;/home&#x27;, &#x27;home&#x27;);","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"validate","slug":"laravel/Validation","date":"2024-03-07T09:34:16.875Z","updated":"2024-03-07T10:02:35.024Z","comments":true,"path":"2024/03/07/laravel/Validation/","link":"","permalink":"http://example.com/2024/03/07/laravel/Validation/","excerpt":"","text":"验证 图片验证 自定义验证错误的信息 用now或yesterday来验证日期 具有某些条件的验证规则 更改默认验证消息 预验证 第一次验证错误时停止 不使用validate或者FormRequest就抛出422 规则取决于其他条件 使用属性设置首次验证失败时停止 unique规则在软删除全局作用域中无效 sometimes方法允许你定义验证器在什么时候被应用 提交自定义验证规则 数组元素验证 Password的defaults方法 表单验证重定向请求 Mac验证规则 验证顶级域名邮箱 图片验证在验证上传的图片时，可以指定所需的尺寸 1[&#x27;photo&#x27; =&gt; &#x27;dimensions:max_width=4096,max_height=4096&#x27;] 自定义验证错误的信息只需在 resources/lang/xx/validation.php 文件创建适当的数组结构，就可以定义定每个 字段、规则和语言的验证错误消息。 12345&#x27;custom&#x27; =&gt; [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27; =&gt; &#x27;We need to know your e-mail address!&#x27;, ],], 用now或yesterday来验证日期您可以使用 before/after 的规则验证日期，并将各种字符串作为参数传递，比如: tomorrow, now, yesterday。例如: &#39;start_date&#39; =&gt; &#39;after:now&#39;。它在底层下使用 strtotime ()。 1234$rules = [ &#x27;start_date&#x27; =&gt; &#x27;after:tomorrow&#x27;, &#x27;end_date&#x27; =&gt; &#x27;after:start_date&#x27;]; 具有某些条件的验证规则如果验证规则依赖于某些条件，则可以通过将 withValidator() 添加到 FormRequest 类中来修改规则，并在那里指定自定义逻辑。例如，如果您只想为某些用户角色添加验证规则。 12345678use Illuminate\\Validation\\Validator;class StoreBlogCategoryRequest extends FormRequest &#123; public function withValidator(Validator $validator) &#123; if (auth()-&gt;user()-&gt;is_admin) &#123; $validator-&gt;addRules([&#x27;some_secret_password&#x27; =&gt; &#x27;required&#x27;]); &#125; &#125;&#125; 更改默认验证消息如果要更改特定字段和特定验证规则的默认验证错误消息，只需将 messages() 方法添加到FormRequest类中。 123456789101112class StoreUserRequest extends FormRequest&#123; public function rules() &#123; return [&#x27;name&#x27; =&gt; &#x27;required&#x27;]; &#125; public function messages() &#123; return [&#x27;name.required&#x27; =&gt; &#x27;User name should be real name&#x27;]; &#125;&#125; 预验证如果你想在默认的Laravel验证之前修改某个字段，或者，换句话说，“准备” 那个字段， FormRequest 类中有一个方法 prepareForValidation () 123456protected function prepareForValidation()&#123; $this-&gt;merge([ &#x27;slug&#x27; =&gt; Illuminate\\Support\\Str::slug($this-&gt;slug), ]);&#125; 第一次验证错误时停止默认情况下，将在列表中返回 Laravel 验证错误，检查所有验证规则。但是如果你想要在第一个错误之后停止这个过程，使用验证规则叫做 bail: 1234$request-&gt;validate([ &#x27;title&#x27; =&gt; &#x27;bail|required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;,]); 如果你需要停止首次错误验证，可以设置FormRequest 类中$stopOnFirstFailure为true: 1protected $stopOnFirstFailure = true; 不使用validate或者FormRequest就抛出422如果您不使用 validate() 或 Form Request，但仍然需要使用相同的 422 状态码和错误结构抛出错误，那么可以手动抛出 throw ValidationException::withMessages() 12345if (! $user || ! Hash::check($request-&gt;password, $user-&gt;password)) &#123; throw ValidationException::withMessages([ &#x27;email&#x27; =&gt; [&#x27;The provided credentials are incorrect.&#x27;], ]);&#125; 规则取决于其他条件如果您的规则是动态的并且依赖于其他条件，那么您可以动态地创建该规则数组 123456789101112131415161718192021public function store(Request $request)&#123; $validationArray = [ &#x27;title&#x27; =&gt; &#x27;required&#x27;, &#x27;company&#x27; =&gt; &#x27;required&#x27;, &#x27;logo&#x27; =&gt; &#x27;file|max:2048&#x27;, &#x27;location&#x27; =&gt; &#x27;required&#x27;, &#x27;apply_link&#x27; =&gt; &#x27;required|url&#x27;, &#x27;content&#x27; =&gt; &#x27;required&#x27;, &#x27;payment_method_id&#x27; =&gt; &#x27;required&#x27; ]; if (!Auth::check()) &#123; $validationArray = array_merge($validationArray, [ &#x27;email&#x27; =&gt; &#x27;required|email|unique:users&#x27;, &#x27;password&#x27; =&gt; &#x27;required|confirmed|min:5&#x27;, &#x27;name&#x27; =&gt; &#x27;required&#x27; ]); &#125; //&#125; 使用属性设置首次验证失败时停止在request类中使用这个属性设置首次验证失败时停止。 注意 这个跟 Bail规则不一样 只在单个规则失败时就停止 123456/*** Indicated if the validator should stop * the entire validation once a single * rule failure has occurred. */protected $stopOnFirstFailure = true; 由 @Sala7JR提供 unique规则在软删除全局作用域中无效Rule::unique 默认不在软删除的全局范围内。但是使用withoutTrashed&#96; 时可用。 1Rule::unique(&#x27;users&#x27;, &#x27;email&#x27;)-&gt;withoutTrashed(); 由 @Zubairmohsin33提供 sometimes方法允许你定义验证器在什么时候被应用Validator::sometimes 方法允许你定义验证器在什么时候被应用，基于提供的输入。这个片段展示了如果购买的物品数量不够，如何禁止使用优惠券。 123456789101112131415161718192021222324252627$data = [ &#x27;coupon&#x27; =&gt; &#x27;PIZZA_PARTY&#x27;, &#x27;items&#x27; =&gt; [ [ &#x27;id&#x27; =&gt; 1, &#x27;quantity&#x27; =&gt; 2 ], [ &#x27;id&#x27; =&gt; 2, &#x27;quantity&#x27; =&gt; 2, ], ],];$validator = Validator::make($data, [ &#x27;coupon&#x27; =&gt; &#x27;exists:coupons,name&#x27;, &#x27;items&#x27; =&gt; &#x27;required|array&#x27;, &#x27;items.*.id&#x27; =&gt; &#x27;required|int&#x27;, &#x27;items.*.quantity&#x27; =&gt; &#x27;required|int&#x27;,]);$validator-&gt;sometimes(&#x27;coupon&#x27;, &#x27;prohibited&#x27;, function (Fluent $data) &#123; return collect($data-&gt;items)-&gt;sum(&#x27;quantity&#x27;) &lt; 5;&#125;);// throws a ValidationException as the quantity provided is not enough$validator-&gt;validate(); Tip given by @cerbero90 数组元素验证如果你想要验证提交的数组元素，使用带*号的点符号。 1234567891011121314151617// say you have this array// array in request &#x27;user_info&#x27;$request-&gt;validated()-&gt;user_info = [ [ &#x27;name&#x27; =&gt; &#x27;Qasim&#x27;, &#x27;age&#x27; =&gt; 26, ], [ &#x27;name&#x27; =&gt; &#x27;Ahmed&#x27;, &#x27;age&#x27; =&gt; 23, ],];// Rule$rules = [ &#x27;user_info.*.name&#x27; =&gt; [&#x27;required&#x27;, &#x27;alpha&#x27;], &#x27;user_info.*.age&#x27; =&gt; [&#x27;required&#x27;, &#x27;numeric&#x27;],]; 由HydroMoon提供 提交自定义验证规则感谢Rule::when 我们可以指定提交验证规则。 下面例子我们可以验证用户是否真的可以对文章点赞。 12345678use Illuminate\\Validation\\Rule;public function rules()&#123; return [ &#x27;vote&#x27; =&gt; Rule::when($user-&gt;can(&#x27;vote&#x27;, $post), &#x27;required|int|between:1,5&#x27;), ]&#125; 由 @cerbero90提供 Password的defaults方法使用Password::defaults方法验证用户提供的密码时，可以强制执行特定规则。它包括要求字母、数字、符号等的选项。 1234567891011121314151617class AppServiceProvider&#123; public function boot(): void &#123; Password::defaults(function () &#123; return Password::min(12) -&gt;letters() -&gt;numbers() -&gt;symbols() -&gt;mixedCase() -&gt;uncompromised(); &#125;) &#125;&#125;request()-&gt;validate([ [&#x27;password&#x27; =&gt; [&#x27;required&#x27;, Password::defaults()]]]) @mattkingshott提供 表单验证重定向请求使用表单请求进行验证时，默认情况下，验证错误将重定向回上一页，但您可以覆盖它 只需定义$redirect或redirectRoute的属性即可 Link to docs Mac验证规则Laravel 8.77添加了新的mac_address规则 123$trans = $this-&gt;getIlluminateArrayTranslator();$validator = new Validator($trans, [&#x27;mac&#x27; =&gt; &#x27;01-23-45-67-89-ab&#x27;], [&#x27;mac&#x27; =&gt; &#x27;mac_address&#x27;]);$this-&gt;assertTrue($validator-&gt;passes()); [@Teacoders] 提供 验证顶级域名邮箱email验证规则将接受一个非顶级域名邮箱 (例子:taylor@laravel, povilas@ldaily) 但是你如果想确保邮箱必须有一个顶级域名 (例子:taylor@laravel.com, povilas@ldaily.com) 使用email:filter规则 1234[ &#x27;email&#x27; =&gt; &#x27;required|email&#x27;, // before &#x27;email&#x27; =&gt; &#x27;required|email:filter&#x27;, // after], @Chris1904提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"数据库模型与 Eloquent","slug":"laravel/DB_Models_and_Eloquent","date":"2024-03-07T09:34:16.874Z","updated":"2024-03-07T10:02:15.661Z","comments":true,"path":"2024/03/07/laravel/DB_Models_and_Eloquent/","link":"","permalink":"http://example.com/2024/03/07/laravel/DB_Models_and_Eloquent/","excerpt":"","text":"数据库模型与 Eloquent 复用或克隆query Eloquent where 日期方法 增量和减量 禁止 timestamp 列 软删除: 多行恢复 Model all: columns To Fail or not to Fail 列名修改 过滤结果集合 修改默认的Timestamp 字段 按照created_at快速排序 当创建记录时自动修改某些列的值 数据库原始查询计算运行得更快 不止一个范围 无需转换 Carbon 根据首字母分组 永不更新某个字段 find () 查询多条数据 find多个模型并返回多列 按照键查找 使用UUID替换auto-increment Laravel 中的子查询 隐藏某些列 确定DB报错 软删除与查询构造器 SQL声明 数据库事务 更新或创建 保存时移除缓存 修改Created_at和Updated_at的格式 数组类型存储到 JSON 中 复制一个模型 降低内存占用 忽略 $fillable&#x2F;$guarded 并强制执行 3层父子级结构 使用 find() 来搜索更多的记录 失败时执行任何操作 检查记录是否存在否则显示 404 条件语句为否时中止 在删除模型之前执行任何额外的操作 当你需要在保存数据到数据库时自动填充一个字段 获取查询语句的额外信息 在 Laravel 中使用doesntExist()方法 在一些模型的 boot () 方法中自动调用一个特性 在 Laravel 中有两种常见的方法来确定一个表是否为空表 如何避免 property of non-object 错误 Eloquent 数据改变后获取原始数据 一种更简单创建数据库的方法 Query构造器的crossJoinSub方法 belongsToMany的中间表命名 根据Pivot字段排序 从数据库中查询一条记录 记录自动分块 定时清理过期记录中的模型 不变的日期和对它们的强制转换 findorfail方法也接收ids数组 从你的数据库中自动移除模型prunableTrait 日期转换 多模型更新&#x2F;插入 过滤结果集之后获取查询构造器 选择聚合计算相关模型 自定义强制转换 保存中不要触发事件 基于相关模型的平均值或总数排序 返回事务结果 从query中移除多个公共scope JSON列属性排序 从第一个结果中获取单列的值 检测模型属性是否被修改 定义访问器与修改器的新方法 另外一种定义访问器与修改器的方法 复用或克隆query通常，我们需要从过滤后的查询中进行更多次查询。因此，大多数时候我们使用 query() 方法，让我们编写一个查询来获取今天创建的可用和不可用的产品 1234567891011$query = Product::query();$today = request()-&gt;q_date ?? today();if($today)&#123; $query-&gt;where(&#x27;created_at&#x27;, $today);&#125;// 让我们获取可用和不可用的产品$active_products = $query-&gt;where(&#x27;status&#x27;, 1)-&gt;get(); // 这一行 修改了$query 对象变量$inactive_products = $query-&gt;where(&#x27;status&#x27;, 0)-&gt;get(); // 所以这里我们将获取不到任何不可用产品 但是，在获得 $active products 后，$query 会被修改。因此 $inactive_products 不会从 $query 中获取到不可用产品，并且每次都返回空集合。因为，它尝试从 $active_products 中查找不可用产品（$query 仅返回可用产品）。 为了解决这个问题,我们可以通过重用这个$query对象来查询多次。因此我们在做任何对$query修改操作的时候需要克隆这个$query。 123$active_products = (clone $query)-&gt;where(&#x27;status&#x27;, 1)-&gt;get(); // it will not modify the $query$inactive_products = (clone $query)-&gt;where(&#x27;status&#x27;, 0)-&gt;get(); // so we will get inactive products from $query Eloquent where日期方法在 Eloquent 中，使用 whereDay()、whereMonth()、whereYear()、whereDate() 和 whereTime() 函数检查日期。 12345$products = Product::whereDate(&#x27;created_at&#x27;, &#x27;2018-01-31&#x27;)-&gt;get();$products = Product::whereMonth(&#x27;created_at&#x27;, &#x27;12&#x27;)-&gt;get();$products = Product::whereDay(&#x27;created_at&#x27;, &#x27;31&#x27;)-&gt;get();$products = Product::whereYear(&#x27;created_at&#x27;, date(&#x27;Y&#x27;))-&gt;get();$products = Product::whereTime(&#x27;created_at&#x27;, &#x27;=&#x27;, &#x27;14:13:58&#x27;)-&gt;get(); 增量和减量如果要增加数据库某个表中的某个列的值，只需要使用 increment() 函数。你不仅可以增加 1，还可以增加其他数字，如 50。 12Post::find($post_id)-&gt;increment(&#x27;view_count&#x27;);User::find($user_id)-&gt;increment(&#x27;points&#x27;, 50); 禁止 timestamp 列如果你的数据库表不包含 timestamp 字段 created_at 和 updated_at，你可以使用 $timestamps = false 属性指定 Eloquent 模型不使用它们。 1234class Company extends Model&#123; public $timestamps = false;&#125; 软删除-多行恢复使用软删除时，可以在一个句子中恢复多行。 1Post::onlyTrashed()-&gt;where(&#x27;author_id&#x27;, 1)-&gt;restore(); Model all-columns当调用Eloquent’s Model::all()时你可以指定返回哪些列。 1$users = User::all([&#x27;id&#x27;, &#x27;name&#x27;, &#x27;email&#x27;]); To Fail or not to Fail除了 findOrFail() 之外，还有 Eloquent 方法 firstOrFail()，如果没有找到查询记录，它将返回 404 页面。 1$user = User::where(&#x27;email&#x27;, &#x27;povilas@laraveldaily.com&#x27;)-&gt;firstOrFail(); 列名修改在 Eloquent Query Builder 中，您可以像在普通 SQL 查询中一样指定as以返回任何列的别名。 1$users = DB::table(&#x27;users&#x27;)-&gt;select(&#x27;name&#x27;, &#x27;email as user_email&#x27;)-&gt;get(); 过滤结果集合在 Eloquent 查询到结果之后，您可以使用 Collections 中的 map() 函数来修改行数据。 1234$users = User::where(&#x27;role_id&#x27;, 1)-&gt;get()-&gt;map(function (User $user) &#123; $user-&gt;some_column = some_function($user); return $user;&#125;); 修改默认的Timestamp 字段如果您使用的是非 Laravel 数据库并且时间戳列的名称不同怎么办？也许，你有 create_time 和 update_time。 幸运的是，您也可以在模型中指定它们： 12345class Role extends Model&#123; const CREATED_AT = &#x27;create_time&#x27;; const UPDATED_AT = &#x27;update_time&#x27;;&#125; 按照created_at快速排序不用: 1User::orderBy(&#x27;created_at&#x27;, &#x27;desc&#x27;)-&gt;get(); 你可以更快的使用排序: 1User::latest()-&gt;get(); 默认情况下 latest() 将按照 created_at排序。 有一个相反的方法 oldest()，按 created_at 升序排序： 1User::oldest()-&gt;get(); 您也可以指定另一列进行排序。 例如，如果你想使用 updated_at，你可以这样做： 1$lastUpdatedUser = User::latest(&#x27;updated_at&#x27;)-&gt;first(); 当创建记录时自动修改某些列的值如果您想在创建记录时生成一些 DB 列值，请将其添加到模型的 boot() 方法中。例如，如果您有一个字段 「position」，并且想要赋值下一个可用位置（如 Country::max(‘position’) + 1)，请执行以下操作： 12345678910class Country extends Model &#123; protected static function boot() &#123; parent::boot(); Country::creating(function($model) &#123; $model-&gt;position = Country::max(&#x27;position&#x27;) + 1; &#125;); &#125;&#125; 数据库原始查询计算运行得更快使用类似 whereRaw() 方法的 SQL 原始查询，直接在查询中进行一些数据库特定计算，而不是在 Laravel 中，通常情况下结果会更快。 例如，如果您想获得注册后 30 天以上仍处于活跃状态的用户，代码如下： 123User::where(&#x27;active&#x27;, 1) -&gt;whereRaw(&#x27;TIMESTAMPDIFF(DAY, created_at, updated_at) &gt; ?&#x27;, 30) -&gt;get(); 不止一个范围您可以在 Eloquent 中组合和链式调用查询范围，在一个query查询中使用多个范围。 Model文件内: 1234567public function scopeActive($query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1);&#125;public function scopeRegisteredWithinDays($query, $days) &#123; return $query-&gt;where(&#x27;created_at&#x27;, &#x27;&gt;=&#x27;, now()-&gt;subDays($days));&#125; 控制器内: 1$users = User::registeredWithinDays(30)-&gt;active()-&gt;get(); 无需转换 Carbon如果你正使用 whereDate() 查询今日的记录，可以直接使用 Carbon 的 now() 方法，它会自动转换为日期进行查询，而不需要指定 -&gt;toDateString()。 1234// 不用$todayUsers = User::whereDate(&#x27;created_at&#x27;, now()-&gt;toDateString())-&gt;get();// 不用做转换 只需要用 now()$todayUsers = User::whereDate(&#x27;created_at&#x27;, now())-&gt;get(); 根据首字母分组你可以用任意自定义条件对 Eloquent 结果进行分组，下面的示例是由用户名的第一个单词进行分组: 123$users = User::all()-&gt;groupBy(function($item) &#123; return $item-&gt;name[0];&#125;); 永不更新某个字段如果有一个数据库字段你想只设置一次并不想再次更新，您可以在Eloquent的模型上使用一个修改器设置该限制： 1234567891011class User extends Model&#123; public function setEmailAttribute($value) &#123; if ($this-&gt;email) &#123; return; &#125; $this-&gt;attributes[&#x27;email&#x27;] = $value; &#125;&#125; find () 查询多条数据find()方法可以接受多参数, 传入多个值时会返回所有找到记录的集合，而不是一个模型: 1234// 返回 Eloquent Model$user = User::find(1);// 返回 Eloquent Collection$users = User::find([1,2,3]); 技巧来自 @tahiriqbalnajam find多个模型并返回多列find方法可接受多参数 使得结果集返回指定列的模型集合，而不是模型的所有列: 1234// Will return Eloquent Model with first_name and email only$user = User::find(1, [&#x27;first_name&#x27;, &#x27;email&#x27;]);// Will return Eloquent Collection with first_name and email only$users = User::find([1,2,3], [&#x27;first_name&#x27;, &#x27;email&#x27;]); 技巧来自 @tahiriqbalnajam 按照键查找您还可以使用whereKey()方法根据您指定的主键查找多条记录。(默认id但是你可以在Eloquent 模型中覆盖掉) 1$users = User::whereKey([1,2,3])-&gt;get(); 使用UUID替换auto-increment您不想在模型中使用自动递增 ID？ 迁移: 1234Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; // $table-&gt;increments(&#x27;id&#x27;); $table-&gt;uuid(&#x27;id&#x27;)-&gt;unique();&#125;); 模型: 12345678910111213141516171819class User extends Model&#123; public $incrementing = false; protected $keyType = &#x27;string&#x27;; protected static function boot() &#123; parent::boot(); User::creating(function ($model) &#123; $model-&gt;setId(); &#125;); &#125; public function setId() &#123; $this-&gt;attributes[&#x27;id&#x27;] = Str::uuid(); &#125;&#125; Laravel 中的子查询从 Laravel 6 开始，您可以在 Eloquent 语句中使用 addSelect()方法，对列进行一些计算。 12345return Destination::addSelect([&#x27;last_flight&#x27; =&gt; Flight::select(&#x27;name&#x27;) -&gt;whereColumn(&#x27;destination_id&#x27;, &#x27;destinations.id&#x27;) -&gt;orderBy(&#x27;arrived_at&#x27;, &#x27;desc&#x27;) -&gt;limit(1)])-&gt;get(); 隐藏某些列在进行 Eloquent 查询时，如果您想在返回中隐藏特定字段，最快捷的方法之一是在集合结果上添加 -&gt;makeHidden()。 1$users = User::all()-&gt;makeHidden([&#x27;email_verified_at&#x27;, &#x27;deleted_at&#x27;]); 确定DB报错如果您想捕获 Eloquent Query 异常，请使用特定的 QueryException 代替默认的 Exception 类，您将能够获得SQL确切的错误代码。 1234567try &#123; // Some Eloquent/SQL statement&#125; catch (\\Illuminate\\Database\\QueryException $e) &#123; if ($e-&gt;getCode() === &#x27;23000&#x27;) &#123; // integrity constraint violation return back()-&gt;withError(&#x27;Invalid data&#x27;); &#125;&#125; 软删除与查询构造器注意 当你用到 Eloquent时 软删除将会起作用，但是查询构造器不行。 12345678// 将排除软删除的条目$users = User::all();// 将不会排除软删除的条目$users = User::withTrashed()-&gt;get();// 将不会排除软删除的条目$users = DB::table(&#x27;users&#x27;)-&gt;get(); SQL声明如果你需要执行一个简单的 SQL 查询，但没有方案 —— 比如改变数据库模式中的某些东西，只需执行 DB::statement()。 12DB::statement(&#x27;DROP TABLE users&#x27;);DB::statement(&#x27;ALTER TABLE projects AUTO_INCREMENT=123&#x27;); 数据库事务如果您执行了两个数据库操作，第二个可能会出错，那么您应该回滚第一个，对吗？为此，我建议使用 DB Transactions，它在 Laravel 中非常简单： 12345DB::transaction(function () &#123; DB::table(&#x27;users&#x27;)-&gt;update([&#x27;votes&#x27; =&gt; 1]); DB::table(&#x27;posts&#x27;)-&gt;delete();&#125;); 更新或创建如果你需要检查记录是否存在，然后更新它，或者创建一个新记录，你可以用一句话来完成 - 使用 Eloquent updateOrCreate() 方法： 12345678910111213141516171819// Instead of this$flight = Flight::where(&#x27;departure&#x27;, &#x27;Oakland&#x27;) -&gt;where(&#x27;destination&#x27;, &#x27;San Diego&#x27;) -&gt;first();if ($flight) &#123; $flight-&gt;update([&#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1]);&#125; else &#123; $flight = Flight::create([ &#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;, &#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1 ]);&#125;// Do it in ONE sentence$flight = Flight::updateOrCreate( [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;], [&#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1]); 保存时移除缓存由 @pratiksh404提供 如果您缓存了一个键存储了 posts 这个集合，想在新增或更新时移除缓存键，可以在您的模型上调用静态的 saved 函数： 1234567891011class Post extends Model&#123; // Forget cache key on storing or updating public static function boot() &#123; parent::boot(); static::saved(function () &#123; Cache::forget(&#x27;posts&#x27;); &#125;); &#125;&#125; 修改Created_at和Updated_at的格式由@syofyanzuhad提供 想要改变 created_at的格式，您可以在模型中添加一个方法，如下所示: 1234public function getCreatedAtFormattedAttribute()&#123; return $this-&gt;created_at-&gt;format(&#x27;H:i d, M Y&#x27;);&#125; 你可以在需要改变时间格式时使用 $entry-&gt;created_at_formatted ，它会返回 created_at 的属性如同 04:19 23, Aug 2020。 你也可以用同样的方法更改 updated_at： 1234public function getUpdatedAtFormattedAttribute()&#123; return $this-&gt;updated_at-&gt;format(&#x27;H:i d, M Y&#x27;);&#125; 在有需要的时候使用 $entry-&gt;updated_at_formatted。它会返回 updated_at 的属性如同: 04:19 23, Aug 2020 。 数组类型存储到 JSON 中由@pratiksh404提供 如果你的输入字段有一个数组需要存储为 JSON 格式，你可以在模型中使用 $casts 属性。 这里的 images 是 JSON 属性 123protected $casts = [ &#x27;images&#x27; =&gt; &#x27;array&#x27;,]; 这样你可以以 JSON 格式存储它，但当你从 DB 中读取时，它会以数组方式使用。 复制一个模型如果你有两个非常相似的模型（比如送货地址和账单地址），而且你想要复制其中一个作为另一个，你可以使用 replicate() 方法并更改一部分属性。 官方文档的示例 12345678910111213$shipping = Address::create([ &#x27;type&#x27; =&gt; &#x27;shipping&#x27;, &#x27;line_1&#x27; =&gt; &#x27;123 Example Street&#x27;, &#x27;city&#x27; =&gt; &#x27;Victorville&#x27;, &#x27;state&#x27; =&gt; &#x27;CA&#x27;, &#x27;postcode&#x27; =&gt; &#x27;90001&#x27;,]);$billing = $shipping-&gt;replicate()-&gt;fill([ &#x27;type&#x27; =&gt; &#x27;billing&#x27;]);$billing-&gt;save(); 降低内存占用有时我们需要将大量的数据加载到内存中，比如： 1$orders = Order::all(); 但如果我们有非常庞大的数据库，这可能会很慢，因为 Laravel 会准备好模型类的对象。在这种情况下，Laravel 有一个很方便的函数 toBase()。 12$orders = Order::toBase()-&gt;get();//$orders 将是一个由`StdClass`组成的 `Illuminate\\Support\\Collection` 通过调用这个方法，它将从数据库中获取数据，但它不会准备模型类。同时，向 get() 方法传递一个字段数组通常是个好主意，这样可以防止从数据库中获取所有字段。 忽略 $fillable&#x2F;$guarded 并强制执行如果你为其他开发者创建了一个 Laravel 模板, 然后你不能控制他们以后会在模型的 $fillable&#x2F;$guarded 中填写什么，你可以使用 forceFill() 1$team-&gt;update([&#x27;name&#x27; =&gt; $request-&gt;name]) 如果 name 不在team模型的 $fillable 中，怎么办？或者如果根本就没有 $fillable/$guarded， 怎么办？ 1$team-&gt;forceFill([&#x27;name&#x27; =&gt; $request-&gt;name]) 这将忽略该查询的 $fillable 并强制执行。 3层父子级结构If you have a 3-level structure of parent-children, like categories in an e-shop, and you want to show the number of products on the third level, you can use with(&#39;yyy.yyy&#39;) and then add withCount() as a condition 1234567891011class HomeController extend Controller&#123; public function index() &#123; $categories = Category::query() -&gt;whereNull(&#x27;category_id&#x27;) -&gt;with([&#x27;subcategories.subcategories&#x27; =&gt; function($query) &#123; $query-&gt;withCount(&#x27;products&#x27;); &#125;])-&gt;get(); &#125;&#125; 123456789101112class Category extends Model&#123; public function subcategories() &#123; return $this-&gt;hasMany(Category::class); &#125; public function products() &#123; return $this-&gt;hasMany(Product::class); &#125;&#125; 1234567891011121314151617181920212223&lt;ul&gt; @foreach($categories as $category) &lt;li&gt; &#123;&#123; $category-&gt;name &#125;&#125; @if ($category-&gt;subcategories) &lt;ul&gt; @foreach($category-&gt;subcategories as $subcategory) &lt;li&gt; &#123;&#123; $subcategory-&gt;name &#125;&#125; @if ($subcategory-&gt;subcategories) &lt;ul&gt; @foreach ($subcategory-&gt;subcategories as $subcategory) &lt;li&gt;&#123;&#123; $subcategory-&gt;name &#125;&#125; (&#123;&#123; $subcategory-&gt;product_count &#125;&#125;)&lt;/li&gt; @endforeach &lt;/ul&gt; @endif &lt;/li&gt; @endforeach &lt;/ul&gt; @endif &lt;/li&gt; @endforeach &lt;/ul&gt; 使用 find() 来搜索更多的记录你不仅可以用 find() 来搜索单条记录，还可以用 IDs 的集合来搜索更多的记录，方法如下： 1return Product::whereIn(&#x27;id&#x27;, $this-&gt;productIDs)-&gt;get(); 这么做: 1return Product::find($this-&gt;productIDs) 失败时执行任何操作当查询一条记录时，如果没有找到，你可能想执行一些操作。除了用 -&gt;firstOrFail() 会抛出 404 之外，你可以在失败时执行任何操作，只需要使用 -&gt;firstOr(function() &#123; ... &#125;) 123$model = Flight::where(&#x27;legs&#x27;, &#x27;&gt;&#x27;, 3)-&gt;firstOr(function () &#123; // ...&#125;) 检查记录是否存在否则显示 404不要使用 find() ，然后再检查记录是否存在，使用 findOrFail() 12345$product = Product::find($id);if (!$product) &#123; abort(404);&#125;$product-&gt;update($productDataArray); 更简单的方法: 12$product = Product::findOrFail($id); // shows 404 if not found$product-&gt;update($productDataArray); 条件语句为否时中止可以使用 abort_if() 作为判断条件和抛出错误页面的快捷方式。 1234$product = Product::findOrFail($id);if($product-&gt;user_id != auth()-&gt;user()-&gt;id)&#123; abort(403);&#125; 更简单的方法: 123/* abort_if(CONDITION, ERROR_CODE) */$product = Product::findOrFail($id);abort_if ($product-&gt;user_id != auth()-&gt;user()-&gt;id, 403) 在删除模型之前执行任何额外的操作由@back2Lobby提供 我们可以使用 Model::delete() 执行额外的操作来覆盖原本的删除方法 123456789// App\\Models\\User.phppublic function delete()&#123; //extra steps here whatever you want //now perform the normal deletion Model::delete();&#125; 当你需要在保存数据到数据库时自动填充一个字段当你需要在保存数据到数据库时自动填充一个字段 （例如: slug），使用模型观察者来代替重复编写代码 1234567891011121314use Illuminate\\Support\\Str;class Article extends Model&#123; ... protected static function boot() &#123; parent:boot(); static::saving(function ($model) &#123; $model-&gt;slug = Str::slug($model-&gt;title); &#125;); &#125;&#125; 由@sky_0xs提供 获取查询语句的额外信息你可以使用 explain() 方法来获取查询语句的额外信息 1Book::where(&#x27;name&#x27;, &#x27;Ruskin Bond&#x27;)-&gt;explain()-&gt;dd(); 123456789101112131415161718Illuminate\\Support\\Collection &#123;#5344 all: [ &#123;#15407 +&quot;id&quot;: 1, +&quot;select_type&quot;: &quot;SIMPLE&quot;, +&quot;table&quot;: &quot;books&quot;, +&quot;partitions&quot;: null, +&quot;type&quot;: &quot;ALL&quot;, +&quot;possible_keys&quot;: null, +&quot;key&quot;: null, +&quot;key_len&quot;: null, +&quot;ref&quot;: null, +&quot;rows&quot;: 9, +&quot;filtered&quot;: 11.11111164093, +&quot;Extra&quot;: &quot;Using where&quot;, &#125;, ],&#125; 由 @amit_merchant提供 在 Laravel 中使用doesntExist()方法12345678910111213// 一个例子if ( 0 === $model-&gt;where(&#x27;status&#x27;, &#x27;pending&#x27;)-&gt;count() ) &#123;&#125;// 我不关心它有多少数据只要它是0// Laravel 的 exists() 方法会很清晰if ( ! $model-&gt;where(&#x27;status&#x27;, &#x27;pending&#x27;)-&gt;exists() ) &#123;&#125;// 但我发现上面这条语句中的！很容易被忽略。// 那么 doesntExist() 方法会让这个例子更加清晰if ( $model-&gt;where(&#x27;status&#x27;, &#x27;pending&#x27;)-&gt;doesntExist() ) &#123;&#125; 由 @ShawnHooper提供 在一些模型的 boot () 方法中自动调用一个特性如果你有一个特性，你想把它添加到几个模型中，自动调用它们的 boot() 方法，你可以把特性的方法作为boot （特性名称）来调用 1234class Transaction extends Model&#123; use MultiTenantModelTrait;&#125; 1234class Task extends Model&#123; use MultiTenantModelTrait;&#125; 12345678910111213trait MultiTenantModelTrait&#123; // This method&#x27;s name is boot[TraitName] // It will be auto-called as boot() of Transaction/Task public static function bootMultiTenantModelTrait() &#123; static::creating(function ($model) &#123; if (!$isAdmin) &#123; $isAdmin-&gt;created_by_id = auth()-&gt;id(); &#125; &#125;) &#125;&#125; Laravel 的 find () 方法，比只传一个 ID 更多的选择1234567// 在 find($id) 方法中第二个参数可以是返回字段Studdents::find(1, [&#x27;name&#x27;, &#x27;father_name&#x27;]);// 这样我们可以查询 ID 为 &#x27;1&#x27; 并返回 name , father_name 字段// 我们可以用数组的方式传递更多的 IDStuddents::find([1,2,3], [&#x27;name&#x27;, &#x27;father_name&#x27;]);// 输出: ID 为 1,2,3 并返回他们的 name , father_name 字段 在 Laravel 中有两种常见的方法来确定一个表是否为空表在 Laravel 中，有两种常见的方法来确定一个表是否为空表。 直接在模型上使用 exists() 或者 count()不等于一个返回严格的布尔值，另一个返回一个整数，你都可以在条件语句中使用。 12345678910public function index()&#123; if (\\App\\Models\\User::exists()) &#123; // returns boolean true or false if the table has any saved rows &#125; if (\\App\\Models\\User::count()) &#123; // returns the count of rows in the table &#125;&#125; 由 @aschmelyun提供 如何避免 property of non-object 错误1234567891011121314151617181920// 设定默认模型// 假设你有一篇 Post （帖子） 属于一个 Author （作者），代码如下:$post-&gt;author-&gt;name;// 当然你可以像这样阻止错误:$post-&gt;author-&gt;name ?? &#x27;&#x27;// 或者@$post-&gt;author-&gt;name// 但你可以在Eloquent关系层面上做到这一点。// 如果没有作者关联帖子，这种关系将返回一个空的App/Author模型。public function author() &#123; return $this-&gt;belongsTo(&#x27;App\\Author&#x27;)-&gt;withDefault();&#125;// 或者public function author() &#123; return $this-&gt;belongsTo(&#x27;App\\Author&#x27;)-&gt;withDefault([ &#x27;name&#x27; =&gt; &#x27;Guest Author&#x27; ]);&#125; 由 @coderahuljat提供 Eloquent 数据改变后获取原始数据Eloquent 模型数据改变后，你可以使用 getOriginal () 方法来获取原始数据 12345$user = App\\User::first();$user-&gt;name; // John$user-&gt;name = &quot;Peter&quot;; // Peter$user-&gt;getOriginal(&#x27;name&#x27;); // John$user-&gt;getOriginal(); // Original $user record 由 @devThaer提供 一种更简单创建数据库的方法Laravel 还可以使用 .sql 文件来更简单的创建数据库 123DB::unprepared( file_get_contents(__DIR__ . &#x27;./dump.sql&#x27;)); 由 @w3Nicolas提供 Query构造器的crossJoinSub方法使用CROSS JOIN交叉连接 1234567use Illuminate\\Support\\Facades\\DB;$totalQuery = DB::table(&#x27;orders&#x27;)-&gt;selectRaw(&#x27;SUM(price) as total&#x27;);DB::table(&#x27;orders&#x27;) -&gt;select(&#x27;*&#x27;) -&gt;crossJoinSub($totalQuery, &#x27;overall&#x27;) -&gt;selectRaw(&#x27;(price / overall.total) * 100 AS percent_of_total&#x27;) -&gt;get(); 由 @PascalBaljet提供 belongsToMany的中间表命名为了决定 关系表的中间表, Eloquent将按字母顺序连接两个相关的型号名称。 这意味着可以这样添加“Post”和“Tag”之间的连接： 12345678class Post extends Model&#123; public $table = &#x27;posts&#x27;; public function tags() &#123; return $this-&gt;belongsToMany(Tag::class); &#125;&#125; 但是，您可以自由重写此约定，并且需要在第二个参数中指定联接表。 12345678class Post extends Model&#123; public $table = &#x27;posts&#x27;; public function tags() &#123; return $this-&gt;belongsToMany(Tag::class, &#x27;posts_tags&#x27;); &#125;&#125; 如果希望明确说明主键，还可以将其作为第三个和第四个参数提供。 12345678class Post extends Model&#123; public $table = &#x27;posts&#x27;; public function tags() &#123; return $this-&gt;belongsToMany(Tag::class, &#x27;post_tag&#x27;, &#x27;post_id&#x27;, &#x27;tag_id&#x27;); &#125;&#125; 由 @iammikek提供 根据Pivot字段排序BelongsToMany::orderByPivot() 允许你直接对BelongsToMany 关系查询的结果集进行排序。 123456789101112131415161718192021222324class Tag extends Model&#123; public $table = &#x27;tags&#x27;;&#125;class Post extends Model&#123; public $table = &#x27;posts&#x27;; public function tags() &#123; return $this-&gt;belongsToMany(Tag::class, &#x27;posts_tags&#x27;, &#x27;post_id&#x27;, &#x27;tag_id&#x27;) -&gt;using(PostTagPivot::class) -&gt;withTimestamps() -&gt;withPivot(&#x27;flag&#x27;); &#125;&#125;class PostTagPivot extends Pivot&#123; protected $table = &#x27;posts_tags&#x27;;&#125;// Somewhere in the Controllerpublic function getPostTags($id)&#123; return Post::findOrFail($id)-&gt;tags()-&gt;orderByPivot(&#x27;flag&#x27;, &#x27;desc&#x27;)-&gt;get();&#125; 由 @PascalBaljet提供 从数据库中查询一条记录sole()方法将会只返回一条匹配标准的记录。如果没找到，将会抛出NoRecordsFoundException 异常。如果发现了多条记录，抛出MultipleRecordsFoundException 异常 1DB::table(&#x27;products&#x27;)-&gt;where(&#x27;ref&#x27;, &#x27;#123&#x27;)-&gt;sole(); 由 @PascalBaljet提供 记录自动分块与each()相同，但是更简单使用。chunks自动将记录分成多块。 1234return User::orderBy(&#x27;name&#x27;)-&gt;chunkMap(fn ($user) =&gt; [ &#x27;id&#x27; =&gt; $user-&gt;id, &#x27;name&#x27; =&gt; $user-&gt;name,]), 25); 由@PascalBaljet提供 定时清理过期记录中的模型定期清理过时记录的模型。有了这个特性，Laravel将自动完成这项工作，只需调整内核类中model:prune命令的频率 123456789101112131415use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\Prunable;class Flight extends Model&#123; use Prunable; /** * Get the prunable model query. * * @return \\Illuminate\\Database\\Eloquent\\Builder */ public function prunable() &#123; return static::where(&#x27;created_at&#x27;, &#x27;&lt;=&#x27;, now()-&gt;subMonth()); &#125;&#125; 此外，在修剪方法中，可以设置删除模型之前必须执行的操作： 123456protected function pruning()&#123; // Removing additional resources, // associated with the model. For example, files. Storage::disk(&#x27;s3&#x27;)-&gt;delete($this-&gt;filename);&#125; 由 @PascalBaljet提供 不变的日期和对它们的强制转换Laravel 8.53 介绍了immutable_date 和immutable_datetime 将日期转换为Immutable&#96;. 转换成CarbonImmutable ，而不是常规的Carbon 实例。 1234567class User extends Model&#123; public $casts = [ &#x27;date_field&#x27; =&gt; &#x27;immutable_date&#x27;, &#x27;datetime_field&#x27; =&gt; &#x27;immutable_datetime&#x27;, ];&#125; 由 @PascalBaljet提供 findorfail方法也接收ids数组findorfail方法也接收ids数组。若无ids被找到 则失败。 若你想拿到一个模型的集合 并不想检测返回数量为你想得到的数量时很好用。 1234567891011User::create([&#x27;id&#x27; =&gt; 1]);User::create([&#x27;id&#x27; =&gt; 2);User::create([&#x27;id&#x27; =&gt; 3]);// Retrives the user...$user = User::findOrFail(1);// Throws a 404 because the user doesn&#x27;t exist...User::findOrFail(99);// Retrives all 3 users...$users = User::findOrFail([1, 2, 3]);// Throws because it is unable to find *all* of the usersUser::findOrFail([1, 2, 3, 99]); 由 @timacdonald87 提供 从你的数据库中自动移除模型prunableTraitLaravel 8.50新特性: 你可以使用prunable trait从你的数据库中自动移除模型。举例:你可以在几天后永久移除软删除的模型。 123456789101112131415161718192021class File extends Model&#123; use SoftDeletes; // Add Prunable trait use Prunable; public function prunable() &#123; // Files matching this query will be pruned return static::query()-&gt;where(&#x27;deleted_at&#x27;, &#x27;&lt;=&#x27;, now()-&gt;subDays(14)); &#125; protected function pruning() &#123; // Remove the file from s3 before deleting the model Storage::disk(&#x27;s3&#x27;)-&gt;delete($this-&gt;filename); &#125;&#125;// Add PruneCommand to your shedule (app/Console/Kernel.php)$schedule-&gt;command(PruneCommand::class)-&gt;daily(); 由 @Philo01提供 日期转换当标记改变时 原来用布尔值来控制模型的可见性，现在可以使用&#96;&#96;something_at 替换。比如 一个产品变成可见: 12345678910111213// MigrationSchema::table(&#x27;products&#x27;, function (Blueprint $table) &#123; $table-&gt;datetime(&#x27;live_at&#x27;)-&gt;nullable();&#125;);// In your modelpublic function live()&#123; return !is_null($this-&gt;live_at);&#125;// Also in your modelprotected $dates = [ &#x27;live_at&#x27;]; 由 @alexjgarrett提供 多模型更新插入upsert()方法将插入&#x2F;更新多个记录。 第一个参数数组:要更新&#x2F;插入的值 第二个:查询表达式中使用的唯一标识列 第三个:若记录存在 你想要更新的列 1234Flight::upsert([ [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;, &#x27;price&#x27; =&gt; 99], [&#x27;departure&#x27; =&gt; &#x27;Chicago&#x27;, &#x27;destination&#x27; =&gt; &#x27;New York&#x27;, &#x27;price&#x27; =&gt; 150],], [&#x27;departure&#x27;, &#x27;destination&#x27;], [&#x27;price&#x27;]); 由 @mmartin_joo提供 过滤结果集之后获取查询构造器你可以使用 toQuery() 在过滤结果集之后获取查询构造器。 该方法在内部使用集合的第一个模型 并使用集合模型上的“whereKey”比较器。(此处翻译拗口 存疑。但是使用方法很明确。) 12345678910// Retrieve all logged_in users$loggedInUsers = User::where(&#x27;logged_in&#x27;, true)-&gt;get();// Filter them using a Collection method or php filtering$nthUsers = $loggedInUsers-&gt;nth(3);// You can&#x27;t do this on the collection$nthUsers-&gt;update(/* ... */);// But you can retrieve the Builder using -&gt;toQuery()if ($nthUsers-&gt;isNotEmpty()) &#123; $nthUsers-&gt;toQuery()-&gt;update(/* ... */);&#125; 由 @RBilloir提供 选择聚合计算相关模型选择聚合计算相关模型。 需要指出的是在一组相关模型上使用count方法要慢一点。 12345678910// In your controller$user = User::withCount(&#x27;articles&#x27;);// Or, to add a constraint to the aggregate$user = User::withCount([ &#x27;articles&#x27; =&gt; fn ($query) =&gt; $query-&gt;live();]);// In your view$user-&gt;articles_count// Instead of$user-&gt;articles-&gt;count(); 由 @alexjgarrett提供 自定义强制转换你可以自定义强制转换来让Laravel自动格式化你的模型数据。 下面是一个在检索或更改用户名时将其大写的示例。 12345678910111213141516171819class CapitalizeWordsCast implements CastsAttributes&#123; public function get($model, string $key, $value, array $attributes) &#123; return ucwords($value); &#125; public function set($model, string $key, $value, array $attributes) &#123; return ucwords($value); &#125;&#125;class User extends Model&#123; protected $casts = [ &#x27;name&#x27; =&gt; CapitalizeWordsCast::class, &#x27;email&#x27; =&gt; &#x27;string&#x27;, ]; &#125; 由 @mattkingshott提供 保存中不要触发事件若你不想触发模型事件 使用saveQuietly()方法 12345678public function quietly()&#123; $user = User::findOrFail(1); $user-&gt;name = &#x27;Martin Joo&#x27;; // Will not trigger any model event $user-&gt;saveQuietly();&#125; 由 @mmartin_joo提供 基于相关模型的平均值或总数排序你是否曾需要基于关系模型的平均值或总数来排序？ 这很简单 123456public function bestBooks()&#123; Book::query() -&gt;withAvg(&#x27;ratings as average_rating&#x27;, &#x27;rating&#x27;) -&gt;orderByDesc(&#x27;average_rating&#x27;);&#125; 由 @mmartin_joo提供 返回事务结果若你有一个DB事务 并且你想返回它的结果 至少有两种方法: 12345678910111213// 1. You can pass the parameter by reference$invoice = NULL;DB::transaction(function () use (&amp;$invoice) &#123; $invoice = Invoice::create(...); $invoice-&gt;items()-&gt;attach(...);&#125;)// 2. Or shorter: just return trasaction result$invoice = DB::transaction(function () &#123; $invoice = Invoice::create(...); $invoice-&gt;items()-&gt;attach(...); return $invoice;&#125;); 从query中移除多个公共scope当使用Global Scopes时 你不仅可以使用多个 scope 而且可以在不需要的时候通过提供的&#96;&#96;withoutGlobalScopes&#96;方法移除他们 Link to docs JSON列属性排序你可以使用JSON列属性排序 123456// JSON column example:// bikes.settings = &#123;&quot;is_retired&quot;: false&#125;$bikes = Bike::where(&#x27;athlete_id&#x27;, $this-&gt;athleteId) -&gt;orderBy(&#x27;name&#x27;) -&gt;orderByDesc(&#x27;settings-&gt;is_retired&#x27;) -&gt;get(); 由 @brbcoding提供 从第一个结果中获取单列的值你可以使用value方法从第一个结果中获取单列的值。 123456// Instead ofIntegration::where(&#x27;name&#x27;, &#x27;foo&#x27;)-&gt;first()-&gt;active;// You can useIntegration::where(&#x27;name&#x27;, &#x27;foo&#x27;)-&gt;value(&#x27;active&#x27;);// or this to throw an exception if no records foundIntegration::where(&#x27;name&#x27;, &#x27;foo&#x27;)-&gt;valueOrFail(&#x27;active&#x27;)&#x27;; 由 @justsanjit提供 检测模型属性是否被修改想知道您对模型所做的更改是否改变了键的值吗？没问题，只需originalIsEquivalent方法即可。 123456$user = User::first(); // [&#x27;name&#x27; =&gt; &quot;John&#x27;]$user-&gt;name = &#x27;John&#x27;;$user-&gt;originalIsEquivalent(&#x27;name&#x27;); // true$user-&gt;name = &#x27;David&#x27;; // Set directly$user-&gt;fill([&#x27;name&#x27; =&gt; &#x27;David&#x27;]); // Or set via fill$user-&gt;originalIsEquivalent(&#x27;name&#x27;); // false 由 [@mattkingshott]提供 定义访问器与修改器的新方法Laravel 8.77:定义访问器与修改器的新方法 1234567891011121314151617// Before, two-method approachpublic function setTitleAttribute($value)&#123; $this-&gt;attributes[&#x27;title&#x27;] = strtolower($value);&#125;public function getTitleAttribute($value)&#123; return strtoupper($value);&#125; // New approachprotected function title(): Attribute&#123; return new Attribute( get: fn ($value) =&gt; strtoupper($value), set: fn ($value) =&gt; strtolower($value),&#125; Tip given by @Teacoders 另外一种定义访问器与修改器的方法在一些模型中想用同样的修改器 访问器 可以自定义转换。 只需要创建一个类 实现 &#96;&#96;CastsAttributes&#96; 实现两个方法 get 标识模型应当从数据库如何拿到 set 标识数据应当如何存储到数据库 123456789101112131415&lt;?phpnamespace App\\Casts;use Carbon\\Carbon;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;class TimestampsCast implements CastsAttributes&#123; public function get($model, string $key, $value, array $attributes) &#123; return Carbon::parse($value)-&gt;diffForHumans(); &#125; public function set($model, string $key, $value, array $attributes) &#123; return Carbon::parse($value)-&gt;format(&#x27;Y-m-d h:i:s&#x27;); &#125;&#125; 然后你可以在模型中实现这个转换 1234567891011121314151617&lt;?phpnamespace App\\Models;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use App\\Casts\\TimestampsCast;use Carbon\\Carbon;class User extends Authenticatable&#123; /** * The attributes that should be cast. * * @var array */ protected $casts = [ &#x27;updated_at&#x27; =&gt; TimestampsCast::class, &#x27;created_at&#x27; =&gt; TimestampsCast::class, ];&#125; [@AhmedRezk]提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"工厂","slug":"laravel/Factories","date":"2024-03-07T09:34:16.874Z","updated":"2024-03-07T10:02:18.330Z","comments":true,"path":"2024/03/07/laravel/Factories/","link":"","permalink":"http://example.com/2024/03/07/laravel/Factories/","excerpt":"","text":"工厂 工厂回调 生成带图像的数据工厂或填充 使用自定义逻辑覆盖值 使用带关联关系的工厂 创建模型而不触发任意事件 有用的for方法 工厂回调使用工厂类进行填充数据时，您可以在插入记录后提供回调函数来执行某种操作。 123$factory-&gt;afterCreating(App\\User::class, function ($user, $faker) &#123; $user-&gt;accounts()-&gt;save(factory(App\\Account::class)-&gt;make());&#125;); 生成带图像的数据工厂或填充你是否知道伪造类 (Faker) 不仅可以生成文本值，还可以生成图像？看此处的 avatar 字段，它将生成一个 50x50 的图像: 12345678910$factory-&gt;define(User::class, function (Faker $faker) &#123; return [ &#x27;name&#x27; =&gt; $faker-&gt;name, &#x27;email&#x27; =&gt; $faker-&gt;unique()-&gt;safeEmail, &#x27;email_verified_at&#x27; =&gt; now(), &#x27;password&#x27; =&gt; bcrypt(&#x27;password&#x27;), &#x27;remember_token&#x27; =&gt; Str::random(10), &#x27;avatar&#x27; =&gt; $faker-&gt;image(storage_path(&#x27;images&#x27;), 50, 50) ];&#125;); 使用自定义逻辑覆盖值当使用工厂类创建记录时，可以使用序列类 (Sequence) 来输入自定义逻辑并将值覆盖 1234567$users = User::factory() -&gt;count(10) -&gt;state(new Sequence( [&#x27;admin&#x27; =&gt; &#x27;Y&#x27;], [&#x27;admin&#x27; =&gt; &#x27;N&#x27;], )) -&gt;create(); 使用带关联关系的工厂当使用带关联关系的工厂时，laravel也提供了魔术方法: 12345// magic factory relationship methodsUser::factory()-&gt;hasPosts(3)-&gt;create();// instead ofUser::factory()-&gt;has(Post::factory()-&gt;count(3))-&gt;create(); 由 @oliverds_提供 创建模型而不触发任意事件有时，您可能希望update给定的模型，而不发送任何事件。您可以使用updateQuietly方法来完成此操作 123456Post::factory()-&gt;createOneQuietly();Post::factory()-&gt;count(3)-&gt;createQuietly();Post::factory()-&gt;createManyQuietly([ [&#x27;message&#x27; =&gt; &#x27;A new comment&#x27;], [&#x27;message&#x27; =&gt; &#x27;Another new comment&#x27;],]); 有用的for方法Laravel工厂有一个非常有用的for方法。您可以使用它来创建belongsTo关系。 1234567public function run()&#123; Product::factory() -&gt;count(3); -&gt;for(Category::factory()-&gt;create()) -&gt;create(); &#125; 由 @mmartin_joo提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"邮件","slug":"laravel/Mail","date":"2024-03-07T09:34:16.874Z","updated":"2024-03-07T10:02:23.266Z","comments":true,"path":"2024/03/07/laravel/Mail/","link":"","permalink":"http://example.com/2024/03/07/laravel/Mail/","excerpt":"","text":"邮件 测试邮件存入laravel.log 预览邮件 不使用Mailables预览邮件 Laravel 通知中的默认邮件主题 向任何人发送通知 测试邮件存入laravel.log如果你想在你的应用中测试邮件内容但是无法或不愿意设置类似 Mailgun 的东西，使用 .env 参数 MAIL_DRIVER=log 然后所有的邮件都会被保存到 storage/logs/laravel.log 文件，而不是真实的发送。 预览邮件如果你使用 Mailables 发送邮件，您可以在浏览器中预览结果，而无需发送。返回一个 Mailables 作为路由结果: 1234Route::get(&#x27;/mailable&#x27;, function () &#123; $invoice = App\\Invoice::find(1); return new App\\Mail\\InvoicePaid($invoice);&#125;); 不使用Mailables预览邮件不使用Mailables你也可以预览你的邮件。举个例子，当你创建通知的时候你可以指定你的邮件通知中可能用到的markdown文件。 12345use Illuminate\\Notifications\\Messages\\MailMessage;Route::get(&#x27;/mailable&#x27;, function () &#123; $invoice = App\\Invoice::find(1); return (new MailMessage)-&gt;markdown(&#x27;emails.invoice-paid&#x27;, compact(&#x27;invoice&#x27;));&#125;); 你也可以使用&#96;&#96;MailMessage 对象提供的view方法和其他方法。 由 @raditzfarhan提供 Laravel 通知中的默认邮件主题如果您发送 Laravel 通知，并且没有在 toMail() 中指定主题，默认主题是您的通知类名，驼峰命名进入控制器。那么，你可以： 123class UserRegistrationEmail extends Notification &#123; //&#125; 然后您将收到一封主题为 用户注册的电子邮件 的电子邮件。 向任何人发送通知你不仅可以发送 Laravel 通知 给特定的用户 $user-&gt;notify()，而且可以发送给你想发给的任何人，通过 Notification::route() ，所谓的 “按需” 通知： 1234Notification::route(&#x27;mail&#x27;, &#x27;taylor@example.com&#x27;) -&gt;route(&#x27;nexmo&#x27;, &#x27;5555555555&#x27;) -&gt;route(&#x27;slack&#x27;, &#x27;https://hooks.slack.com/services/...&#x27;) -&gt;notify(new InvoicePaid($invoice));","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"数据库迁移","slug":"laravel/Migrations","date":"2024-03-07T09:34:16.874Z","updated":"2024-03-07T10:02:25.905Z","comments":true,"path":"2024/03/07/laravel/Migrations/","link":"","permalink":"http://example.com/2024/03/07/laravel/Migrations/","excerpt":"","text":"数据库迁移 无符号整型 迁移顺序 带时区的迁移字段 数据库迁移字段类型 默认时间戳 迁移状态 创建带空格的迁移 在另一列的后面创建一列 为已经存在的表生成迁移文件 执行迁移前先输出 SQL 语句 匿名迁移 给迁移添加注释 表名表字段检测 无符号整型作为迁移的外键，请使用 unsignedInteger() 类型或 integer()-&gt;unsigned() 来替代 integer() ，否则你会得到 SQL 错误。 12345Schema::create(&#x27;employees&#x27;, function (Blueprint $table) &#123; $table-&gt;unsignedInteger(&#x27;company_id&#x27;); $table-&gt;foreign(&#x27;company_id&#x27;)-&gt;references(&#x27;id&#x27;)-&gt;on(&#x27;companies&#x27;); // ...&#125;); 同样，你可以用 unsignedBigInteger() 如果外键对应的是 bigInteger() 类型。 123Schema::create(&#x27;employees&#x27;, function (Blueprint $table) &#123; $table-&gt;unsignedBigInteger(&#x27;company_id&#x27;);&#125;); 迁移顺序如果你想改变数据库迁移的顺序，只需要将文件按时间戳记命名， 就像 2018_08_04_070443_create_posts_table.php 改为 2018_07_04_070443_create_posts_table.php (从 2018_08_04 改成了 2018_07_04). 迁移是以字母顺序执行。 带时区的迁移字段你知不知道在迁移中不止有 timestamps() 还有带时区的 timestampsTz() 。 123456Schema::create(&#x27;employees&#x27;, function (Blueprint $table) &#123; $table-&gt;increments(&#x27;id&#x27;); $table-&gt;string(&#x27;name&#x27;); $table-&gt;string(&#x27;email&#x27;); $table-&gt;timestampsTz();&#125;); 同样，还有这么些列 dateTimeTz() ， timeTz() ， timestampTz() ， softDeletesTz()。 数据库迁移字段类型迁移中有一些有趣的字段类型，下面是一些示例。 12345$table-&gt;geometry(&#x27;positions&#x27;);$table-&gt;ipAddress(&#x27;visitor&#x27;);$table-&gt;macAddress(&#x27;device&#x27;);$table-&gt;point(&#x27;position&#x27;);$table-&gt;uuid(&#x27;id&#x27;); 在 官方文档 中你可以找到全部的字段类型列表. 默认时间戳当创建迁移文件时，你可以使用带useCurrent() 和 useCurrentOnUpdate() 可选项的 timestamp() 类型，这将会设置使相应字段以 CURRENT_TIMESTAMP 作为默认值。 12$table-&gt;timestamp(&#x27;created_at&#x27;)-&gt;useCurrent();$table-&gt;timestamp(&#x27;updated_at&#x27;)-&gt;useCurrentOnUpdate(); 迁移状态如果你想知道迁移是不是已经运行过了，不需要查看 “migrations” 表，你可以运行 php artisan migrate:status 命令来查看。 结果示例: 1234567+------+------------------------------------------------+-------+| Ran? | Migration | Batch |+------+------------------------------------------------+-------+| Yes | 2014_10_12_000000_create_users_table | 1 || Yes | 2014_10_12_100000_create_password_resets_table | 1 || No | 2019_08_19_000000_create_failed_jobs_table | |+------+------------------------------------------------+-------+ 创建带空格的迁移当你打入 make:migration 命令，你不 “必须” 在不同部分间使用下划线 _ 进行分隔，比如 create_transactions_table 。你可以把名字用引号引起来并把下划线换成空格。 12345// This worksphp artisan make:migration create_transactions_table// But this works toophp artisan make:migration &quot;create transactions table&quot; Source: Steve O on Twitter 在另一列的后面创建一列注意： 仅 MySQL 可用如果你要在已经存在的表里增加一个新列，这个列不 “必须” 成为最后一列，你可以指定这个列创建在哪个列的后面 123Schema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;phone&#x27;)-&gt;after(&#x27;email&#x27;);&#125;); 如果你要在已经存在的表里增加一个新列，这个列不 “必须” 成为最后一列，你也可以指定这个列创建在哪个列的前面： 123Schema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;phone&#x27;)-&gt;before(&#x27;created_at&#x27;);&#125;); 如果你让创建的列排在表中的第一个，那么可以使用 first 方法。 123Schema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;uuid&#x27;)-&gt;first();&#125;); 为已经存在的表生成迁移文件如果你要为已经存的表生成迁移文件，而且你想让 Lavarel 来为你生成 Schema::table () 代码，那么，在命令后面加入 “_in_xxxxx_table” 或”_to_xxxxx_table”，或者指明 “–table” 参数。php artisan make:migration change_fields_products_table generates empty class 1234567class ChangeFieldsProductsTable extends Migration&#123; public function up() &#123; // &#125;&#125; 但是，加入 in_xxxxx_table php artisan make:migration change_fields_in_products_table 生成了填好了 Schemma::table() 的类。 123456789class ChangeFieldsProductsTable extends Migration&#123; public function up() &#123; Schema::table(&#x27;products&#x27;, function (Blueprint $table) &#123; // &#125;) &#125;;&#125; 同样，你可以指明 --table 参数 php artisan make:migration whatever_you_want --table=products 123456789class WhateverYouWant extends Migration&#123; public function up() &#123; Schema::table(&#x27;products&#x27;, function (Blueprint $table) &#123; // &#125;) &#125;;&#125; 执行迁移前先输出 SQL 语句当输入 migrate –pretend 命令，你可以得到将在终端中执行的 SQL 查询。如果有需要的话调试 SQL 的方法，这是个很有趣的方法。 12// Artisan commandphp artisan migrate --pretend @zarpelon 提供 匿名迁移Laravel团队发布了Laravel 8.37版本 支持匿名迁移，解决了迁移命名冲突的问题。 这个问题的核心是 如果多个迁移有相同的类名 当尝试重新创建数据库时可能会导致问题 以下是一个来自 pr 的例子 12345678910111213141516171819use Illuminate\\Database\\Migrations\\Migration;use Illuminate\\Database\\Schema\\Blueprint;use Illuminate\\Support\\Facades\\Schema;return new class extends Migration &#123; public function up( &#123; Schema::table(&#x27;people&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;first_name&#x27;)-&gt;nullable(); &#125;); &#125; public function down() &#123; Schema::table(&#x27;people&#x27;, function (Blueprint $table) &#123; $table-&gt;dropColumn(&#x27;first_name&#x27;); &#125;); &#125;&#125;; 由 @nicksdot提供 给迁移添加注释在迁移中你可以给字段添加 comment 提供有用的信息。 如果数据库被其他开发者管理,他们在任何操作之前可以看这些表结构的注释。 123$table-&gt;unsignedInteger(&#x27;interval&#x27;) -&gt;index() -&gt;comment(&#x27;This column is used for indexing.&#x27;) 由 @Zubairmohsin33提供 表名表字段检测你可以使用 hasTable 和 hasColumn 方法检测表或字段是否存在。 123456if (Schema::hasTable(&#x27;users&#x27;)) &#123; // The &quot;users&quot; table exists...&#125;if (Schema::hasColumn(&#x27;users&#x27;, &#x27;email&#x27;)) &#123; // The &quot;users&quot; table exists and has an &quot;email&quot; column...&#125; @dipeshsukhia提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"日志与调试","slug":"laravel/Log_and_Debug","date":"2024-03-07T09:34:16.874Z","updated":"2024-03-07T10:02:20.994Z","comments":true,"path":"2024/03/07/laravel/Log_and_Debug/","link":"","permalink":"http://example.com/2024/03/07/laravel/Log_and_Debug/","excerpt":"","text":"日志与调试 日志记录参数 更方便的 DD 使用 context 日志 快速输出Query的sql 开发模式打印所有数据库查询 日志记录参数你可以使用 Log::info()，或使用更短的 info() 额外参数信息，来了解更多发生的事情 1Log::info(&#x27;User failed to login.&#x27;, [&#x27;id&#x27; =&gt; $user-&gt;id]); 更方便的 DD你可以在你的 Eloquent 句子或者任何集合结尾添加 -&gt;dd()，而不是使用 dd($result) 12345// Instead of$users = User::where(&#x27;name&#x27;, &#x27;Taylor&#x27;)-&gt;get();dd($users);// Do this$users = User::where(&#x27;name&#x27;, &#x27;Taylor&#x27;)-&gt;get()-&gt;dd(); 使用 context 日志在最新的 Laravel 8.49 中：Log::withContext() 将帮助您区分不同请求之间的日志消息。如果你创建了中间件并且设置了 context，所有的长消息将包含在 context 中，你将会搜索更容易。 123456789101112public function handle(Request $request, Closure $next)&#123; $requestId = (string) Str::uuid(); Log::withContext([&#x27;request-id&#x27; =&gt; $requestId]); $response = $next($request); $response-&gt;header(&#x27;request-id&#x27;, $requestId); return $response;&#125; 由 @LaraibiM提供 快速输出Query的sql如果你想快速输出一个 Eloquent query的sql 你可以调用 toSql()方法如下: 1234$invoices = Invoice::where(&#x27;client&#x27;, &#x27;James pay&#x27;)-&gt;toSql();dd($invoices)// select * from `invoices` where `client` = ? @devThaer提供 开发模式打印所有数据库查询如果要在开发期间记录所有数据库查询，请将此代码段添加到AppServiceProvider 12345678public function boot()&#123; if (App::environment(&#x27;local&#x27;)) &#123; DB::listen(function ($query) &#123; logger(Str::replaceArray(&#x27;?&#x27;, $query-&gt;bindings, $query-&gt;sql)); &#125;); &#125;&#125; @mmartin_joo提供","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"授权","slug":"laravel/Auth","date":"2024-03-07T09:34:16.873Z","updated":"2024-03-07T10:02:09.584Z","comments":true,"path":"2024/03/07/laravel/Auth/","link":"","permalink":"http://example.com/2024/03/07/laravel/Auth/","excerpt":"","text":"授权 一次检查多个权限 更多关于用户注册的事件 你知道Auth::once()吗 更改用户密码更新的API令牌 覆盖超级管理员的权限 一次检查多个权限除了 @can Blade 指令外，你知道可以用 @canany 指令一次检查多个权限吗？ 12345@canany([&#x27;update&#x27;, &#x27;view&#x27;, &#x27;delete&#x27;], $post) // The current user can update, view, or delete the post@elsecanany([&#x27;create&#x27;], \\App\\Post::class) // The current user can create a post@endcanany 更多关于用户注册的事件希望在新用户注册后执行一些操作？ 转到 app/Providers/EventServiceProvider.php 和 添加更多的监听类，然后在 $event-&gt;user 对象中实现 handle() 方法。 12345678910class EventServiceProvider extends ServiceProvider&#123; protected $listen = [ Registered::class =&gt; [ SendEmailVerificationNotification::class, // You can add any Listener class here // With handle() method inside of that class ], ]; 你知道Authonce吗你可以用用户登录一个请求，使用方法 Auth::once()。不会使用任何会话或 cookie，这意味着该方法在构建无状态 API 时可能很有帮助。 123if (Auth::once($credentials)) &#123; //&#125; 更改用户密码更新的API令牌当用户的密码更改时，可以方便地更改用户的 API 令牌。模型： 12345public function setPasswordAttribute($value)&#123; $this-&gt;attributes[&#x27;password&#x27;] = $value; $this-&gt;attributes[&#x27;api_token&#x27;] = Str::random(100);&#125; 覆盖超级管理员的权限如果你已经定义了网关（Gates）但是又想要覆盖超级管理员的所有权限。 给超级管理员所有权限，你可以在 AuthServiceProvider.php 文件中用 Gate::before() 语句拦截网关（Gates）。 12345678910111213// Intercept any Gate and check if it&#x27;s super adminGate::before(function($user, $ability) &#123; if ($user-&gt;is_super_admin == 1) &#123; return true; &#125;&#125;);// Or if you use some permissions package...Gate::before(function($user, $ability) &#123; if ($user-&gt;hasPermission(&#x27;root&#x27;)) &#123; return true; &#125;&#125;);","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"Artisan","slug":"laravel/Artisan","date":"2024-03-07T09:34:16.873Z","updated":"2024-03-07T10:02:07.032Z","comments":true,"path":"2024/03/07/laravel/Artisan/","link":"","permalink":"http://example.com/2024/03/07/laravel/Artisan/","excerpt":"","text":"Artisan Artisan 命令参数 维护模式 Artisan 命令行帮助 确认 Laravel 的版本 从任意处使用 Artisan 命令 Artisan 命令参数创建 Artisan 命令时，您可以各种方式询问输入：$this-&gt;confirm() （确认），$this-&gt;perialipate() (预期输入)，$this-&gt;choice()(选择)。 12345678910// Yes or no?if ($this-&gt;confirm(&#x27;Do you wish to continue?&#x27;)) &#123; //&#125;// Open question with auto-complete options$name = $this-&gt;anticipate(&#x27;What is your name?&#x27;, [&#x27;Taylor&#x27;, &#x27;Dayle&#x27;]);// One of the listed options with default index$name = $this-&gt;choice(&#x27;What is your name?&#x27;, [&#x27;Taylor&#x27;, &#x27;Dayle&#x27;], $defaultIndex); 维护模式如果你想要在页面上启用维护模式，执行下面的 Artisan 命令: 1php artisan down 然后人们会看到默认的 503 页面。在 Laravel 8 里，你还可以提供的标识： 用户将会重定向的路径地址预渲染的维护模式视图页面绕过维护模式的秘钥维护模式返回的状态吗每 X 秒重新加载页面 1php artisan down --redirect=&quot;/&quot; --render=&quot;errors::503&quot; --secret=&quot;1630542a-246b-4b66-afa1-dd72a4c43515&quot; --status=200 --retry=60 在 Laravel 8 之前有： 维护模式显示的消息 每 X 秒重新加载页面 允许访问的 IP 地址 1php artisan down --message=&quot;Upgrading Database&quot; --retry=60 --allow=127.0.0.1 当你完成了维护工作，只需要运行： 1php artisan up Artisan 命令行帮助要查看 Artisan 命令的相关选项，可以运行 Artisan 命令带上 --help 标识参数，比如 php artisan make:model --help 然后就可以看到你可以用到的诸多选项 123456789101112131415161718Options: -a, --all Generate a migration, seeder, factory, and resource controller for the model -c, --controller Create a new controller for the model -f, --factory Create a new factory for the model --force Create the class even if the model already exists -m, --migration Create a new migration file for the model -s, --seed Create a new seeder file for the model -p, --pivot Indicates if the generated model should be a custom intermediate table model -r, --resource Indicates if the generated controller should be a resource controller --api Indicates if the generated controller should be an API controller -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question --env[=ENV] The environment the command should run under -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug 确认 Laravel 的版本通过以下命令行，可以查看并确认你的应用所使用 Lavavel 版本php artisan --version 从任意处使用 Artisan 命令你不仅可以在命令行中启动Artisan 命令，还可以携带参数地在代码中启动它，使用&#96;Artisan::call()· 方法即可： 1234567Route::get(&#x27;/foo&#x27;, function () &#123; $exitCode = Artisan::call(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--queue&#x27; =&gt; &#x27;default&#x27; ]); //&#125;);","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"集合","slug":"laravel/Collections","date":"2024-03-07T09:34:16.873Z","updated":"2024-03-07T10:02:11.503Z","comments":true,"path":"2024/03/07/laravel/Collections/","link":"","permalink":"http://example.com/2024/03/07/laravel/Collections/","excerpt":"","text":"集合 不要使用NULL过滤集合 使用自定义的回调函数对集合分组 针对行的集合方法 对分页集合求和 分页组件中的唯一标识 高阶集合方法 Higher order collection message 不要使用NULL过滤集合你可以在 Eloquent 中使用 NULL 过滤，但是你不能用 NULL 过滤 集合 - 你应该换成空字符串过滤，字段中已经没有 “null”。(意思是全字符串的形式的过滤不能使用 NULL，因为会被格式化为 [“field is null”, “&#x3D;”, true]) 123456789// This works$messages = Message::where(&#x27;read_at is null&#x27;)-&gt;get();// Won’t work - will return 0 messages$messages = Message::all();$unread_messages = $messages-&gt;where(&#x27;read_at is null&#x27;)-&gt;count();// Will work$unread_messages = $messages-&gt;where(&#x27;read_at&#x27;, &#x27;&#x27;)-&gt;count(); 使用自定义的回调函数对集合分组如果你想对结果分组，且分组字段不对应数据库中的字段，你可以提供一个回调函数来返回自定义的分组字段。例如，通过用户的注册日分组，代码如下： 123$users = User::all()-&gt;groupBy(function($item) &#123; return $item-&gt;created_at-&gt;format(&#x27;Y-m-d&#x27;);&#125;); 注意：这个方法是在 Collection 类上的，所以将会在数据库的返回结果上执行。(意思不会在数据库 sql 层面分组) 针对行的集合方法你可以用 -&gt;all() , -&gt;get() 方法查询数据，然后在这个返回的集合上执行各种集合方法，执行集合操作不会每次都查询数据库。 1234$users = User::all();echo &#x27;Max ID: &#x27; . $users-&gt;max(&#x27;id&#x27;);echo &#x27;Average age: &#x27; . $users-&gt;avg(&#x27;age&#x27;);echo &#x27;Total budget: &#x27; . $users-&gt;sum(&#x27;budget&#x27;); 对分页集合求和如何对分页返回的结果集求和？使用相同的查询构建器，在分页查询之前执行求和操作 1234567891011// How to get sum of post_views with pagination?$posts = Post::paginate(10);// This will be only for page 1, not ALL posts$sum = $posts-&gt;sum(&#x27;post_views&#x27;);// Do this with Query Builder$query = Post::query();// Calculate sum$sum = $query-&gt;sum(&#x27;post_views&#x27;);// And then do the pagination from the same query$posts = $query-&gt;paginate(10); 分页组件中的唯一标识我们可以在分页组件中像序列号那样使用每趟循环中的索引 index ，作为分页组件的唯一标识。 12345678...&lt;th&gt;Serial&lt;/th&gt; ... @foreach ($products as $product) &lt;tr&gt; &lt;td&gt;&#123;&#123; $loop-&gt;index + $product-&gt;firstItem() &#125;&#125;&lt;/td&gt; ... @endforeach 这可以解决下一页（?page&#x3D;2&amp;…）索引的计数问题。 高阶集合方法集合具有更高阶的可以链式调用的方法，例如 groupBy() map() 等，给你流畅的语法体验。下面的例子计算了一个需求单中每组产品的价格。 12345678910111213$offer = [ &#x27;name&#x27; =&gt; &#x27;offer1&#x27;, &#x27;lines&#x27; =&gt; [ [&#x27;group&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 10], [&#x27;group&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 20], [&#x27;group&#x27; =&gt; 2, &#x27;price&#x27; =&gt; 30], [&#x27;group&#x27; =&gt; 2, &#x27;price&#x27; =&gt; 40], [&#x27;group&#x27; =&gt; 3, &#x27;price&#x27; =&gt; 50], [&#x27;group&#x27; =&gt; 3, &#x27;price&#x27; =&gt; 60] ]]; $totalPerGroup = collect($offer-&gt;lines)-&gt;groupBy(&#x27;group&#x27;)-&gt;map(fn($group) =&gt; $group-&gt;sum(&#x27;price&#x27;)); 高阶集合排序集合还支持“高阶排序”，这是对集合执行常见操作的捷径。 此示例计算报价中每组产品的价格。 12345678910111213$offer = [ &#x27;name&#x27; =&gt; &#x27;offer1&#x27;, &#x27;lines&#x27; =&gt; [ [&#x27;group&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 10], [&#x27;group&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 20], [&#x27;group&#x27; =&gt; 2, &#x27;price&#x27; =&gt; 30], [&#x27;group&#x27; =&gt; 2, &#x27;price&#x27; =&gt; 40], [&#x27;group&#x27; =&gt; 3, &#x27;price&#x27; =&gt; 50], [&#x27;group&#x27; =&gt; 3, &#x27;price&#x27; =&gt; 60] ]]; $totalPerGroup = collect($offer[&#x27;lines&#x27;])-&gt;groupBy-&gt;group-&gt;map-&gt;sum(&#x27;price&#x27;);","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"API","slug":"laravel/API","date":"2024-03-07T09:34:16.873Z","updated":"2024-03-07T10:02:04.012Z","comments":true,"path":"2024/03/07/laravel/API/","link":"","permalink":"http://example.com/2024/03/07/laravel/API/","excerpt":"","text":"API API 返回一切正常 去掉额外的内部数据包装 API resource中避免N+1查询 从Authorizationheader中获取BearerToken 排序API结果 由 @phillipmwaniki提供 API 返回一切正常如果你有 API 端口执行某些操作但是没有响应，那么您只想返回 “一切正常”, 您可以返回 204 状态代码 “No content”。在 Laravel 中，很简单: return response()-&gt;noContent(); 12345678public function reorder(Request $request)&#123; foreach ($request-&gt;input(&#x27;rows&#x27;, []) as $row) &#123; Country::find($row[&#x27;id&#x27;])-&gt;update([&#x27;position&#x27; =&gt; $row[&#x27;position&#x27;]]); &#125; return response()-&gt;noContent();&#125; 去掉额外的内部数据包装当创建一个 Laravel Resource 集合 你可以去除数据外层包装, 通过在 AppServiceProvider中添加 JsonResource::withoutWrapping() 1234public function boot()&#123; JsonResource::withoutWrapping();&#125; 避免N+1查询在API resource资源中你可以使用whenLoaded方法避免N+1查询。 如果Employee 模型准备好了加载的时候 才会被加载。如果没有whenLoaded department每次都会执行查询。Without whenLoaded() there is always a query for the department 12345678910111213class EmplyeeResource extends JsonResource&#123; public function toArray($request): array &#123; return [ &#x27;id&#x27; =&gt; $this-&gt;uuid, &#x27;fullName&#x27; =&gt; $this-&gt;full_name, &#x27;email&#x27; =&gt; $this-&gt;email, &#x27;jobTitle&#x27; =&gt; $this-&gt;job_title, &#x27;department&#x27; =&gt; DepartmentResource::make($this-&gt;whenLoaded(&#x27;department&#x27;)), ]; &#125;&#125; Tip given by @mmartin_joo 从Authorizationheader中获取BearerToken当你使用api并想访问bearerToken时bearerToken方法很方便. 12345// Don&#x27;t parse API headers manually like this:$tokenWithBearer = $request-&gt;header(&#x27;Authorization&#x27;);$token = substr($tokenWithBearer, 7);//Do this instead:$token = $request-&gt;bearerToken(); 由 @iamharis010提供 排序APi结果单行API排序 使用方向控制 1234567891011// Handles /dogs?sort=name and /dogs?sort=-nameRoute::get(&#x27;dogs&#x27;, function (Request $request) &#123; // Get the sort query parameter (or fall back to default sort &quot;name&quot;) $sortColumn = $request-&gt;input(&#x27;sort&#x27;, &#x27;name&#x27;); // Set the sort direction based on whether the key starts with - // using Laravel&#x27;s Str::startsWith() helper function $sortDirection = Str::startsWith($sortColumn, &#x27;-&#x27;) ? &#x27;desc&#x27; : &#x27;asc&#x27;; $sortColumn = ltrim($sortColumn, &#x27;-&#x27;); return Dog::orderBy($sortColumn, $sortDirection) -&gt;paginate(20);&#125;); 我们可以为多行实现同样的效果 如?sort&#x3D;name,-weight 123456789101112131415// Handles ?sort=name,-weightRoute::get(&#x27;dogs&#x27;, function (Request $request) &#123; // Grab the query parameter and turn it into an array exploded by , $sorts = explode(&#x27;,&#x27;, $request-&gt;input(&#x27;sort&#x27;, &#x27;&#x27;)); // Create a query $query = Dog::query(); // Add the sorts one by one foreach ($sorts as $sortColumn) &#123; $sortDirection = Str::startsWith($sortColumn, &#x27;-&#x27;) ? &#x27;desc&#x27; : &#x27;asc&#x27;; $sortColumn = ltrim($sortColumn, &#x27;-&#x27;); $query-&gt;orderBy($sortColumn, $sortDirection); &#125; // Return return $query-&gt;paginate(20);&#125;);","categories":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"}]},{"title":"yii2-admin","slug":"yii/yii2-admin","date":"2023-10-08T08:15:51.000Z","updated":"2023-10-12T02:41:48.856Z","comments":true,"path":"2023/10/08/yii/yii2-admin/","link":"","permalink":"http://example.com/2023/10/08/yii/yii2-admin/","excerpt":"","text":"在 Yii2 中，你可以使用 RBAC（Role-Based Access Control）来控制菜单权限按钮。以下是基本步骤： 安装 Yii2 RBAC 扩展： 首先，你需要安装 Yii2 的 RBAC 扩展，可以使用 Yii2 的官方扩展 yii2-admin，它提供了一套强大的 RBAC 管理功能。 你可以通过 Composer 安装： 1composer require mdmsoft/yii2-admin &quot;~2.0&quot; 安装完成后，你可以按照文档配置和初始化 RBAC。 创建角色和权限： 在 Yii2 RBAC 中，你需要创建角色和权限，然后将它们关联起来。你可以使用 yii\\rbac\\DbManager 或者其他适合你项目的 RBAC 组件来管理角色和权限。 12345678910// 创建一个角色$role = $auth-&gt;createRole(&#x27;admin&#x27;);$auth-&gt;add($role);// 创建一个权限$permission = $auth-&gt;createPermission(&#x27;createPost&#x27;);$auth-&gt;add($permission);// 关联权限到角色$auth-&gt;addChild($role, $permission); 在 Controller 中验证权限： 在你的控制器中，可以使用 beforeAction 方法来检查用户是否具有执行该操作的权限。 12345678910111213public function beforeAction($action)&#123; if (!parent::beforeAction($action)) &#123; return false; &#125; // 检查当前用户是否有权限执行该操作 if (!Yii::$app-&gt;user-&gt;can(&#x27;createPost&#x27;)) &#123; throw new ForbiddenHttpException(&#x27;你没有权限执行该操作&#x27;); &#125; return true;&#125; 在视图中显示按钮： 在视图文件中，可以使用 yii\\rbac\\CheckAccessWidget 小部件来根据用户的权限显示或隐藏按钮。 123456789&lt;?phpuse yii\\rbac\\CheckAccessWidget;// 显示按钮，如果用户有 &#x27;createPost&#x27; 权限echo CheckAccessWidget::widget([ &#x27;name&#x27; =&gt; &#x27;createPost&#x27;, &#x27;yes&#x27; =&gt; Html::a(&#x27;Create Post&#x27;, [&#x27;post/create&#x27;]),]);?&gt; 在视图中控制菜单显示： 你可以使用 Yii::$app-&gt;user-&gt;can() 方法来在视图中根据用户的权限来控制菜单的显示或隐藏。 123if (Yii::$app-&gt;user-&gt;can(&#x27;createPost&#x27;)) &#123; echo Html::a(&#x27;Create Post&#x27;, [&#x27;post/create&#x27;]);&#125; 以上步骤提供了一个基本的 Yii2 RBAC 权限控制方案。通过创建角色、权限以及在控制器和视图中验证权限，你可以实现对菜单按钮的权限控制。","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"yii","slug":"php/yii","permalink":"http://example.com/categories/php/yii/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"yii","slug":"yii","permalink":"http://example.com/tags/yii/"}]},{"title":"linux","slug":"工具/linux","date":"2023-09-27T06:24:55.000Z","updated":"2023-09-27T06:31:50.139Z","comments":true,"path":"2023/09/27/工具/linux/","link":"","permalink":"http://example.com/2023/09/27/%E5%B7%A5%E5%85%B7/linux/","excerpt":"","text":"你可以使用 grep 命令来查询文件中的关键内容，并结合 head 和 tail 命令来显示前后的行数。以下是具体的命令： 12345grep &#x27;关键词&#x27; 文件名 | head -n 100 &amp;&amp; grep &#x27;关键词&#x27; 文件名 | tail -n 100grep &#x27;MY20230923090G4T03&#x27; sjq_org_c23-pro238.log | head -n 100 &amp;&amp; grep &#x27;MY20230923090G4T03&#x27; sjq_org_c23-pro238.log | tail -n 100 解释： grep &#39;关键词&#39; 文件名 会在指定的文件中搜索包含关键词的行。 head -n 100 会显示前100行。 tail -n 100 会显示最后100行。 如果你想在一个命令中实现，可以使用 awk： 1awk &#x27;/MY20230923090G4T03/&#123;a=NR+100&#125; a&amp;&amp;NR&lt;=a&#x27; sjq_org_c23-pro238.log 这个命令会在文件中查找包含关键词的行，并显示每个匹配行的前后100行。","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Yii2 行为类","slug":"yii/yii3","date":"2023-08-28T08:00:04.000Z","updated":"2023-08-30T03:03:17.525Z","comments":true,"path":"2023/08/28/yii/yii3/","link":"","permalink":"http://example.com/2023/08/28/yii/yii3/","excerpt":"","text":"yii2 Behavior 行为的使用，代码示例1.定义一个类继承行为基础类2.实现event方法触发事件重写 如下是扩展模型Model的类方法 进行程序的解耦设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpnamespace app\\common\\behaviors;use yii\\base\\Behavior;use yii\\db\\BaseActiveRecord;use yii\\web\\UploadedFile;/*** * * 行为事件 测试类 * * @package app\\common\\behaviors * @class AttachmentsBehavior * @date 2023-08-30 */class AttachmentsBehavior extends Behavior&#123; private $_files; /** * 需要上传的文件属性 * @var string */ public $uploadFiles = &#x27;uploadfiles&#x27;; /** * 已经上传了的文件属性 * @var string */ public $uploadedFiles = &#x27;uploadedfiles&#x27;; /** * 保存路径 * @var string */ public $savePath = &#x27;@common/upload&#x27;; /** * 访问路径 * @var string */ public $saveUrl = &#x27;@common/uploads&#x27;; public function events() &#123; return [ BaseActiveRecord::EVENT_BEFORE_VALIDATE =&gt; &#x27;beforeValidate&#x27;, BaseActiveRecord::EVENT_AFTER_VALIDATE =&gt; &#x27;beforeValidate1&#x27;, BaseActiveRecord::EVENT_AFTER_INSERT =&gt; &#x27;afterSave&#x27;, BaseActiveRecord::EVENT_AFTER_UPDATE =&gt; &#x27;afterSave&#x27;, BaseActiveRecord::EVENT_BEFORE_DELETE =&gt; &#x27;beforeDelete&#x27;, ]; &#125; /** * This method is invoked before validation starts. */ public function beforeValidate1() &#123; $this-&gt;_files = UploadedFile::getInstances($this-&gt;owner, $this-&gt;uploadFiles); &#125; /** * 返回拥有者的唯一Id * @return string */ public function getIdentityId() &#123; return $this-&gt;owner-&gt;className() . &#x27;.&#x27; . $this-&gt;owner-&gt;id; &#125; /** * 明确拥有者与附件的关系 * @return mixed */ public function getAttachments() &#123; return $this-&gt;owner-&gt;hasMany(Attachments::className(), [&#x27;ownerId&#x27; =&gt; &#x27;identityId&#x27;]); &#125; /** * 在主模型保存后挨个保存附件 */ public function afterSave() &#123; foreach ($this-&gt;_files as $file) &#123; $model = new Attachments(); $model-&gt;fileName = $file-&gt;name; $model-&gt;url = date(&#x27;Ymd&#x27;) . \\Yii::$app-&gt;getSecurity()-&gt;generateRandomString(8) . &#x27;.&#x27; . $file-&gt;extension; $model-&gt;ownerId = $this-&gt;owner-&gt;identityId; $model-&gt;savePath = \\Yii::getAlias($this-&gt;savePath); $file-&gt;saveAs(\\Yii::getAlias($this-&gt;savePath) . DIRECTORY_SEPARATOR . $model-&gt;url); $model-&gt;save(); &#125; &#125; /** * 在主模型删除之前删除所有附件 * @return bool */ public function beforeDelete() &#123; foreach ($this-&gt;owner-&gt;&#123;$this-&gt;uploadedFiles&#125; as $file) &#123; $file-&gt;delete(); &#125; return true; &#125; /** * @param $url * @return string * @date 2023-08-30 */ public function getFilesUrl($url) &#123; return \\Yii::getAlias($this-&gt;saveUrl) . DIRECTORY_SEPARATOR . $url; &#125;&#125; 参考资料","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"yii","slug":"php/yii","permalink":"http://example.com/categories/php/yii/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"yii","slug":"yii","permalink":"http://example.com/tags/yii/"}]},{"title":"备忘录","slug":"test/pass","date":"2023-08-24T01:24:14.000Z","updated":"2023-08-24T01:26:59.944Z","comments":true,"path":"2023/08/24/test/pass/","link":"","permalink":"http://example.com/2023/08/24/test/pass/","excerpt":"","text":"备份记录oopdingtalk.com &#39;Jinx525617 #123&#39;","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"备忘录","slug":"备忘录","permalink":"http://example.com/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"}]},{"title":"博客构建同步仓库","slug":"工具/hexo","date":"2023-08-16T00:53:39.000Z","updated":"2023-08-16T00:58:23.819Z","comments":true,"path":"2023/08/16/工具/hexo/","link":"","permalink":"http://example.com/2023/08/16/%E5%B7%A5%E5%85%B7/hexo/","excerpt":"","text":"使用国内访问源快速 vercel静态托管 1.仓库地址https://vercel.com/jianqiangsong/blog 2.访问地址同步博客地址 https://blog-jianqiangsong.vercel.app","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"前端/hexo","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/hexo/"}],"tags":[{"name":"博客构建","slug":"博客构建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA/"}]},{"title":"openai 图片使用demo","slug":"工具/openai","date":"2023-08-16T00:44:03.000Z","updated":"2023-08-16T00:58:51.837Z","comments":true,"path":"2023/08/16/工具/openai/","link":"","permalink":"http://example.com/2023/08/16/%E5%B7%A5%E5%85%B7/openai/","excerpt":"","text":"openiakey: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 生成图片，使用代理访问的openai 12345678curl https://api.openai-proxy.com/v1/images/generations \\ -H &quot;Content-Type: application/json&quot; \\ -H &quot;Authorization: Bearer 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&quot; \\ -d &#x27;&#123; &quot;prompt&quot;: &quot;生成一张小王八的照片&quot;, &quot;n&quot;: 2, &quot;size&quot;: &quot;256x256&quot; &#125;&#x27;","categories":[{"name":"openai","slug":"openai","permalink":"http://example.com/categories/openai/"},{"name":"大语言模型","slug":"openai/大语言模型","permalink":"http://example.com/categories/openai/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"openai","slug":"openai","permalink":"http://example.com/tags/openai/"}]},{"title":"函数","slug":"php/函数","date":"2023-08-08T01:37:23.000Z","updated":"2023-10-17T01:50:46.774Z","comments":true,"path":"2023/08/08/php/函数/","link":"","permalink":"http://example.com/2023/08/08/php/%E5%87%BD%E6%95%B0/","excerpt":"","text":"发现一个比较好用容易忽略的函数 get_headers 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//判断一个地址是否可以访问 //302 状态码代表重定向 $arr = get_headers(&#x27;https://test-open.zking.com/dz/1Msvv137&#x27;, 1); //响应结果，可以通过content-length 判断 Array( [0] =&gt; HTTP/1.1 302 Found [Server] =&gt; Array ( [0] =&gt; ****** [1] =&gt; ****** ) [Content-Length] =&gt; 0 [Connection] =&gt; Array ( [0] =&gt; close [1] =&gt; close ) [location] =&gt; https://test-open.zking.com/api/v1/insurance/nonAutoMobile/getpolicyDownload/21122253410023000009 [date] =&gt; Array ( [0] =&gt; Tue, 08 Aug 2023 01:52:24 GMT [1] =&gt; Tue, 08 Aug 2023 01:52:25 GMT ) [x-envoy-upstream-service-time] =&gt; Array ( [0] =&gt; 81 [1] =&gt; 1442 ) [Set-Cookie] =&gt; Array ( [0] =&gt; hvAJjymUYBa3O=60Tt1N123.awkhkof7ofH3MhYWigGg6G0q12mi2Pc4QhKnBw5gWoZvGiQd5pxELY81iyYE6YcTHQ8LLwiyHCHkVA; Path=/; expires=Fri, 05 Aug 2033 01:52:19 GMT; Secure; HttpOnly [1] =&gt; hvAJjymUYBa3O=60Kb23jk82hM1gsG2k2MF54_7K.PDdJPJTGBuC7VHqCO_tps6JCbWBAvIx7x_FPDw9gbkXICkvy9qlYQWrTP2Jva; Path=/; expires=Fri, 05 Aug 2033 01:52:20 GMT; Secure; HttpOnly ) [1] =&gt; HTTP/1.1 200 OK [Content-Type] =&gt; application/octet-stream;charset=UTF-8 [pragma] =&gt; public [expires] =&gt; 0 [cache-control] =&gt; must-revalidate, post-check=0, pre-check=0 [content-disposition] =&gt; attachment;filename=21122253410023000009.pdf [x-kong-upstream-latency] =&gt; 1437 [x-kong-proxy-latency] =&gt; 5 [via] =&gt; kong/2.5.2) PHP获取本周日期1234567891011121314&lt;?php// 获取今天的日期$today = date(&#x27;Y-m-d&#x27;);// 使用 strtotime 函数获取本周的起始日期$start_of_week = date(&#x27;Y-m-d&#x27;, strtotime(&#x27;this week&#x27;, strtotime($today)));// 使用 strtotime 函数获取本周的结束日期$end_of_week = date(&#x27;Y-m-d&#x27;, strtotime(&#x27;this week +6 days&#x27;, strtotime($start_of_week)));echo &quot;本周起始日期是：&quot; . $start_of_week . &quot;&lt;br&gt;&quot;;echo &quot;本周结束日期是：&quot; . $end_of_week;","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"基础","slug":"php/基础","permalink":"http://example.com/categories/php/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"函数 get_headers","slug":"函数-get-headers","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0-get-headers/"}]},{"title":"yii2","slug":"yii/yii2","date":"2023-07-28T08:00:04.000Z","updated":"2023-08-30T01:49:10.326Z","comments":true,"path":"2023/07/28/yii/yii2/","link":"","permalink":"http://example.com/2023/07/28/yii/yii2/","excerpt":"","text":"yii2 干货知识集合 https://github.com/forecho/awesome-yii2 链接地址 件一共有15个与加密解密（&amp;编码）相关的公共方法 encryptByPassword encryptByKey decryptByPassword decryptByKey hkdf pbkdf2 hashData validateData generateRandomKey generateRandomString generatePasswordHash validatePassword compareString maskToken unmaskToken 我想有一些你一定没见过，没关系，我们一一去了解。 generateRandomString 之所以先说generateRandomString是因为它最常用，起码我是这样。 public function generateRandomString($length = 32)&#123;...&#125; 生成一个随机的字符串，参数$length代表这个字符串的长度，默认32位。值得说明的是这个字符串的取值为范围是[A-Za-z0-9_-]。 generatePasswordHash &amp; validatePassword generatePasswordHash &amp; validatePassword经常被用来加密用户密码以及对密码是否正确的验证，自从MD5可能被碰撞后，我们用yii2开发应用的时候，generatePasswordHash函数对密码进行加密就成为首选了，它调用了crypt函数。 一般用法如下 // 使用generatePasswordHash为用户的密码加密，$hash存储到库中 $hash = Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash($password); &#x2F;&#x2F; 使用validatePassword对密码进行验证if(Yii::$app-&gt;getSecurity()-&gt;validatePassword($password, $hash))&#123;&#x2F;&#x2F; 密码正确&#125;else&#123;&#x2F;&#x2F; 密码错误&#125; generateRandomKey 和generateRandomString类似，生成一个随机的串，参数为长度，默认为32位，区别在于generateRandomKey生成的不是ASCII。 简单的说 generateRandomString 约等于 base64_encode(generateRandomKey)。 encryptByPassword &amp; decryptByPassword 编码和解码函数，使用一个秘钥对数据进行编码，然后通过此秘钥在对编码后的数据进行解码。 例子 $dat = Yii::$app-&gt;security-&gt;encryptByPassword(\"hello\",\"3166886\"); echo Yii::$app-&gt;security-&gt;encryptByPassword($dat,\"3166886\");// hello 要注意，通过上面得到的编码后的数据不是ASCII，可以通过base64_encode和base64_decode在外层包装下。 encryptByKey &amp; decryptByKey 同样是一组编码和解码函数，比通过密码的方式要快。函数声明为 public function encryptByKey($data, $inputKey, $info = null)&#123;&#125; public function decryptByKey($data, $inputKey, $info &#x3D; null)&#123;&#125; encryptByKey &amp; decryptByKey 存在着第三个参数，比如我们可以传递会员的ID等，这样此信息将和$inputKey一起作为加密解密的钥匙。 hkdf 使用标准的 HKDF 算法从给定的输入键中导出一个键。在PHP7+使用的是hash_hkdf方法，小于PHP7使用hash_hmac方法。 pbkdf2 使用标准的 PBKDF2 算法从给定的密码导出一个密钥。该方法可以用来进行密码加密，不过yii2有更好的密码加密方案 generatePasswordHash。 hashData和validateData 有的时候为了防止内容被篡改，我们需要对数据进行一些标记，hashData和validateData就是完成这个任务的组合。 hashData 用来对原始数据进行加数据前缀，比如如下代码 $result = Yii::$app-&gt;security-&gt;hashData(\"hello\",'123456',false); // ac28d602c767424d0c809edebf73828bed5ce99ce1556f4df8e223faeec60eddhello 你看到了在hello的前面多了一组字符，这组字符会随着原始数据的不同而变化。这样我们就对数据进行了特殊的防止篡改标记，接下来是validateData上场了。 注意：hashData的第三个参数代表生成的哈希值是否为原始二进制格式. 如果为false, 则会生成小写十六进制数字. validateData 对已经加了数据前缀的数据进行检测，如下代码 $result = Yii::$app-&gt;security-&gt;validateData(\"ac28d602c767424d0c809edebf73828bed5ce99ce1556f4df8e223faeec60eddhello\",'123456',false); // hello 如果返回了原始的字符串则表示验证通过，否则会返回假。 validateData 函数的第三个参数应该与使用 hashData() 生成数据时的值相同. 它指示数据中的散列值是否是二进制格式. 如果为false, 则表示散列值仅由小写十六进制数字组成. 将生成十六进制数字. compareString 可防止时序攻击的字符串比较，用法非常简单。 Yii::$app-&gt;security-&gt;compareString(\"abc\",'abc'); 结果为真则相等，否则不相等。 那么什么是时序攻击那？我来举一个简单的例子。 if($code == Yii::$app-&gt;request-&gt;get('code'))&#123; &#125; 上面的比较逻辑，两个字符串是从第一位开始逐一进行比较的，发现不同就立即返回 false，那么通过计算返回的速度就知道了大概是哪一位开始不同的，这样就实现了电影中经常出现的按位破解密码的场景。 而使用 compareString 比较两个字符串，无论字符串是否相等，函数的时间消耗是恒定的，这样可以有效的防止时序攻击。 maskToken &amp;&amp; unmaskToken maskToken用于掩盖真实token且不可以压缩，同一个token最后生成了不同的随机令牌，在yii2的csrf功能上就使用了maskToken，原理并不复杂，我们看下源码。 public function maskToken($token)&#123; $mask = $this-&gt;generateRandomKey(StringHelper::byteLength($token)); return StringHelper::base64UrlEncode($mask . ($mask ^ $token)); &#125; 而unmaskToken目的也很明确，用于得到被maskToken掩盖的token。 接下来我们看一个例子代码 $token = Yii::$app-&gt;security-&gt;maskToken(\"123456\"); echo Yii::$app-&gt;security-&gt;unmaskToken($token);// 结果为 123456 最后我们总结下 加密/解密: encryptByKey()、decryptByKey()、 encryptByPassword() 和 decryptByPassword()； 使用标准算法的密钥推导: pbkdf2() 和 hkdf(); 防止数据篡改: hashData() 和 validateData(); 密码验证: generatePasswordHash() 和 validatePassword()","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"yii","slug":"php/yii","permalink":"http://example.com/categories/php/yii/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"yii","slug":"yii","permalink":"http://example.com/tags/yii/"}]},{"title":"IOC/DI","slug":"php/ioc","date":"2023-07-21T01:29:46.000Z","updated":"2024-03-06T08:59:16.801Z","comments":true,"path":"2023/07/21/php/ioc/","link":"","permalink":"http://example.com/2023/07/21/php/ioc/","excerpt":"","text":"1.一句话说明依赖注入因为大多数应用程序都是由两个或者更多的类通过彼此合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么将导致代码高度耦合并且难以维护和调试 不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。 2.上面俩种方法代码很清晰，但是当我们需要注入很多个依赖时，意味着又要增加很多行，会比较难以管理。比较好的解决办法是 建立一个class作为所有依赖关系的container，在这个class中可以存放、创建、获取、查找需要的依赖关系。先来了解一下IOC的概念 3.控制反转 （Inversion Of Control, IOC）控制反转 是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做 依赖注入（Dependency Injection, DI）, 还有一种叫”依赖查找”（DependencyLookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 12345678910111213&lt;?phpclass Ioc &#123; protected $db_conn; public static function make_book() &#123; $new_book = new Book(); $new_book-&gt;set_db(self::$db_conn); //... //... //其他的依赖注入 return $new_book; &#125;&#125; 此时，如果获取一个book实例，只需要执行$newone &#x3D; Ioc::makebook(); 以上是container的一个具体实例，最好还是不要把具体的某个依赖注入写成方法，采用registry注册，get获取比较好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php/** * 控制反转类 */class Ioc &#123; /** * @var array 注册的依赖数组 */ protected static $registry = array(); /** * 添加一个 resolve （匿名函数）到 registry 数组中 * * @param string $name 依赖标识 * @param Closure $resolve 一个匿名函数，用来创建实例 * @return void */ public static function register($name, Closure $resolve) &#123; static::$registry[$name] = $resolve; &#125; /** * 返回一个实例 * * @param string $name 依赖的标识 * @return mixed * @throws \\Exception */ public static function resolve($name) &#123; if (static::registered($name)) &#123; $name = static::$registry[$name]; return $name(); &#125; throw new \\Exception(&quot;Nothing registered with that name&quot;); &#125; /** * 查询某个依赖实例是否存在 * * @param string $name * @return bool */ public static function registered($name) &#123; return array_key_exists($name, static::$registry); &#125;&#125; 现在就可以通过如下方式来注册和注入一个 12345678Ioc::register(&quot;book&quot;, function () &#123; $book = new Book(); $book-&gt;setdb(&#x27;db&#x27;); $book-&gt;setfile(&#x27;file&#x27;); return $book;&#125;); // 注入依赖$book = Ioc::resolve(&#x27;book&#x27;); 4.问题汇总参与者都有谁？答：一般有三方参与者，一个是某个对象；一个是IoC&#x2F;DI的容器；另一个是某个对象的外部资源。又要名词解释一下，某个对象指的就是任意的、普通的Java对象;IoC&#x2F;DI的容器简单点说就是指用来实现IoC&#x2F;DI功能的一个框架程序；对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。 依赖：谁依赖于谁？为什么会有依赖？答：某个对象依赖于IoC&#x2F;DI的容器。依赖是不可避免的，在一个项目中，各个类之间有各种各样的关系，不可能全部完全独立，这就形成了依赖。传统的开发是使用其他类时直接调用，这会形成强耦合，这是要避免的。依赖注入借用容器转移了被依赖对象实现解耦。 注入：谁注入于谁？到底注入什么？答：通过容器向对象注入其所需要的外部资源 控制反转：谁控制谁？控制什么？为什么叫反转？答：IoC&#x2F;DI的容器控制对象，主要是控制对象实例的创建。反转是相对于正向而言的，那么什么算是正向的呢？考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC&#x2F;DI的容器获取一个C的实例，然后反向的注入到A类中。 依赖注入和控制反转是同一概念吗？答：从上面可以看出：依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源 参考参考参考 附上一个di&#x2F;ioc的写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?phpinterface db&#123; public function select();&#125;class MysqlDb implements db&#123; public function select()&#123; echo &#x27;MysqlDb select&#x27;; &#125;&#125;class MongoDb implements db&#123; public function select()&#123; echo &#x27;MongoDb select&#x27;; &#125;&#125;class User&#123; protected $db; public function __construct(db $db) //约束注入类型 &#123; $this-&gt;db = $db; &#125; public function select() &#123; $this-&gt;db-&gt;select(); &#125;&#125;class Ioc&#123; public $binding = []; public function bind($abstract, $concrete) &#123; //绑定返回一个闭包，这里还不需要执行，仅做绑定 $this-&gt;binding[$abstract][&#x27;concrete&#x27;] = function ($ioc) use ($concrete) &#123; return $ioc-&gt;build($concrete); &#125;; &#125; public function make($abstract) &#123; //获取绑定的闭包，并执行 return $this-&gt;binding[$abstract][&#x27;concrete&#x27;]($this); &#125; //创建对象 public function build($concrete) &#123; //ReflectionClass反射（reflection）类报告了一个类的有关信息 $reflector = new ReflectionClass($concrete); //getConstructor获取类的构造函数 $constructor = $reflector-&gt;getConstructor(); if (is_null($constructor)) &#123; //实例化对象 newInstance从指定的参数创建一个新的类实例 return $reflector-&gt;newInstance(); &#125;else &#123; //获取构成函数的参数 getParameters获取参数 $dependen = $constructor-&gt;getParameters(); //获取依赖 getDependencies $intances = $this-&gt;getDependencies($dependen); //newInstanceArgs 从给出的参数创建一个新的类实例 return $reflector-&gt;newInstanceArgs($intances); &#125; &#125; //获取依赖，如果存在依赖就创建依赖 protected function getDependencies($dependen) &#123; $dependencies = []; foreach ($dependen as $paramter)&#123; $dependencies[] = $this-&gt;make($paramter-&gt;getClass()-&gt;name); &#125; return $dependencies; &#125;&#125;$ioc = new Ioc();$ioc-&gt;bind(&#x27;db&#x27;,&#x27;MysqlDb&#x27;);$ioc-&gt;bind(&#x27;user&#x27;,&#x27;User&#x27;);$user = $ioc-&gt;make(&#x27;user&#x27;);$user-&gt;select();$ioc-&gt;bind(&#x27;db&#x27;,&#x27;MongoDb&#x27;);$user = $ioc-&gt;make(&#x27;user&#x27;);$user-&gt;select();$ioc-&gt;bind(&#x27;db&#x27;,&#x27;MysqlDb&#x27;);$user = $ioc-&gt;make(&#x27;user&#x27;);$user-&gt;select(); 文本","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"基础","slug":"php/基础","permalink":"http://example.com/categories/php/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://example.com/tags/ioc/"},{"name":"di","slug":"di","permalink":"http://example.com/tags/di/"}]},{"title":"外链文章","slug":"工具/link","date":"2023-07-20T08:31:45.000Z","updated":"2023-08-29T09:59:15.024Z","comments":true,"path":"2023/07/20/工具/link/","link":"","permalink":"http://example.com/2023/07/20/%E5%B7%A5%E5%85%B7/link/","excerpt":"","text":"第三方外链 easy-tips yii2","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"基础","slug":"php/基础","permalink":"http://example.com/categories/php/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"外链","slug":"外链","permalink":"http://example.com/tags/%E5%A4%96%E9%93%BE/"}]},{"title":"yii 请求头","slug":"yii/yii","date":"2023-07-19T05:58:15.000Z","updated":"2023-07-19T06:06:08.165Z","comments":true,"path":"2023/07/19/yii/yii/","link":"","permalink":"http://example.com/2023/07/19/yii/yii/","excerpt":"","text":"平时不怎么注意到的问题， yii 模拟请求表单提交 数据json字符串 php://input 也能接受参数 实际查看debug传参是当作整个json 当作key内容 代码 1234567891011121314151617181920212223242526//curl 代码 模拟客户端请求$ch = curl_init();$data = [&#x27;username&#x27; =&gt; &#x27;周伯通&#x27;, &#x27;password&#x27; =&gt; &#x27;123456&#x27;, &#x27;sign&#x27; =&gt; &#x27;asdfg123456&#x27;];$url = &#x27;sjqfront.com/bid_v3/qingjian/apply&#x27;;$ch = curl_init(); //初始化curlcurl_setopt($ch, CURLOPT_URL, $url);//设置链接curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//设置是否返回信息curl_setopt($ch, CURLOPT_POST, 1);//设置为POST方式curl_setopt($ch, CURLOPT_HEADER, array(&#x27;Content-type: application/x-www-form-urlencoded;charset=UTF-8&#x27;));//设置为POST方式curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));//POST数据curl_setopt($ch, CURLOPT_USERAGENT, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;);$response = curl_exec($ch);//接收返回信息if (curl_errno($ch)) &#123;//出错则显示错误信息 print curl_error($ch);&#125;curl_close($ch); //关闭curl链接file_put_contents(&#x27;1.txt&#x27;,$response,FILE_APPEND);exit();// yii响应头默认 text/html$r = \\Yii::$app-&gt;request-&gt;getRawBody();print_r(json_decode($r,true));exit();","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"yii","slug":"php/yii","permalink":"http://example.com/categories/php/yii/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"yii","slug":"yii","permalink":"http://example.com/tags/yii/"}]},{"title":"火车方案","slug":"生活/装修","date":"2023-07-18T07:49:03.277Z","updated":"2024-03-08T02:09:26.014Z","comments":true,"path":"2023/07/18/生活/装修/","link":"","permalink":"http://example.com/2023/07/18/%E7%94%9F%E6%B4%BB/%E8%A3%85%E4%BF%AE/","excerpt":"","text":"深圳-赤壁回家方案：周五6点下班走，离公司最近火车站 深圳东站-东莞东站K1020 18:55 - 19:36 坐票(¥26.5) K642 19:24 - 20:02 坐票(¥26.5)东莞东站-赤壁站 仅有一趟车K437 21:10-09:38 卧铺(¥248.5)赤壁-深圳回家方案：T95 19:42 - 07:25 卧铺(¥238.5)","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"记录","slug":"生活/记录","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"汽车投诉车质网","slug":"生活/装修-1","date":"2023-07-18T07:49:03.000Z","updated":"2023-09-28T03:45:12.399Z","comments":true,"path":"2023/07/18/生活/装修-1/","link":"","permalink":"http://example.com/2023/07/18/%E7%94%9F%E6%B4%BB/%E8%A3%85%E4%BF%AE-1/","excerpt":"","text":"尊敬的车质网： 我是一名拥有一辆XXX型号汽车的车主，我对我所购买的这辆车的质量和性能感到非常担忧和失望。在我购买这辆车之后，不久便发现了严重的方向盘问题，这让我非常担忧。 首先，我要反映的问题是方向盘过重。在驾驶过程中，我发现方向盘异常沉重，特别是在低速行驶和停车时。这使得操控变得异常困难，严重影响了驾驶安全性。在繁忙的交通中，我不得不付出更大的力气来转动方向盘，这不仅令我疲惫不堪，也增加了驾驶的风险。我相信这绝非正常状况，也严重违反了一辆车的基本行驶标准。 其次，与方向盘过重问题密切相关的是转向困难。由于方向盘异常沉重，我在转弯时遇到了严重的困难。在紧急情况下，我甚至无法迅速地正确转向，这极大地威胁了我的行车安全。我曾多次感到惊恐和无助，因为我无法准确地控制我的车辆，这让我非常担忧。 我购买这辆车的初衷是希望拥有一辆安全可靠的交通工具，但现在我却因为方向盘重、转向困难的严重问题感到十分失望和焦虑。我认为这绝不是一辆符合基本质量标准的汽车，我对这样的产品质量感到极为失望。 我诚恳地希望车质网能够尽快对我的投诉进行认真审核，并协助我解决这个严重的问题。我迫切需要厂家对这辆车的方向盘问题进行检修或更换，以确保我的行车安全。 最后，我也希望通过我的投诉，提醒其他消费者对于购买汽车时务必审慎选择，避免遭受类似的质量问题，保障自己和家人的行车安全。 再次感谢车质网对我的关注与帮助，我期待着尽快得到问题的解决。 此致，[您的姓名][联系方式]","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"记录","slug":"生活/记录","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"go语言","slug":"golang/go","date":"2023-07-18T06:32:25.000Z","updated":"2023-07-20T06:04:32.450Z","comments":true,"path":"2023/07/18/golang/go/","link":"","permalink":"http://example.com/2023/07/18/golang/go/","excerpt":"","text":"参考资料","categories":[{"name":"golang","slug":"golang","permalink":"http://example.com/categories/golang/"},{"name":"基础","slug":"golang/基础","permalink":"http://example.com/categories/golang/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"项目笔记","slug":"日常项目备注/项目笔记","date":"2023-07-18T06:26:21.000Z","updated":"2023-07-18T06:27:44.272Z","comments":true,"path":"2023/07/18/日常项目备注/项目笔记/","link":"","permalink":"http://example.com/2023/07/18/%E6%97%A5%E5%B8%B8%E9%A1%B9%E7%9B%AE%E5%A4%87%E6%B3%A8/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考资料 促销系统1 促销系统2","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"笔记","slug":"项目/笔记","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"工具","slug":"工具/ps","date":"2023-07-18T06:14:55.000Z","updated":"2023-07-18T07:52:52.946Z","comments":true,"path":"2023/07/18/工具/ps/","link":"","permalink":"http://example.com/2023/07/18/%E5%B7%A5%E5%85%B7/ps/","excerpt":"","text":"vscode 快捷键选中一段文字，按shift+alt+i，可以在每行末尾出现光标 批量编辑 phpstrom一直按Alt+J apipost 全局设置参数1234&#123;&#123;token&#125;&#125;&#123;&#123;auth-key&#125;&#125;apt.variables.set(&#x27;token&#x27;,response.json.data.token);apt.variables.set(&#x27;auth-key&#x27;,response.json.data.auth_key); chartgptsk-jHfsqqBjw6wqozDtRtybT3BlbkFJXrC4fXjhe9Tdgab6JCcx phpstorm debug调式?XDEBUG_SESSION_START=PHPSTROM 要将两行合并为一行并移除不必要的空格，请按 ⌃⇧J。","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"phpstrom","slug":"php/phpstrom","permalink":"http://example.com/categories/php/phpstrom/"}],"tags":[{"name":"phpstorm","slug":"phpstorm","permalink":"http://example.com/tags/phpstorm/"}]},{"title":"laravel 创建Facades门面","slug":"php/laravel","date":"2023-07-18T06:13:00.000Z","updated":"2023-10-07T00:38:01.873Z","comments":true,"path":"2023/07/18/php/laravel/","link":"","permalink":"http://example.com/2023/07/18/php/laravel/","excerpt":"","text":"要自定义门面，你需要遵循以下步骤： 创建门面类： 首先，创建一个继承自 Illuminate\\Support\\Facades\\Facade 的门面类。这个类将作为你自定义门面的接口。 例如，假设你想创建一个名为 CustomFacade 的门面： 12345678910111213&lt;?phpnamespace App\\Facades;use Illuminate\\Support\\Facades\\Facade;class CustomFacade extends Facade&#123; protected static function getFacadeAccessor() &#123; return &#x27;custom&#x27;; // 对应服务容器中的标识符 &#125;&#125; 在这个例子中，CustomFacade 的 getFacadeAccessor 方法返回了 &#39;custom&#39;，这个标识符将用于在服务容器中查找相应的实例。 创建服务提供者： 接下来，你需要创建一个服务提供者，将自定义服务注册到 Laravel 中。 1php artisan make:provider CustomServiceProvider 在生成的 CustomServiceProvider.php 中，你可以在 register 方法中注册自定义服务： 123456public function register()&#123; $this-&gt;app-&gt;bind(&#x27;custom&#x27;, function ($app) &#123; return new \\App\\Services\\CustomService(); &#125;);&#125; 在这个例子中，我们将一个名为 custom 的标识符与一个自定义的服务类绑定。 在配置文件中注册服务提供者： 打开 config/app.php 配置文件，将你的服务提供者添加到 providers 数组中： 1234&#x27;providers&#x27; =&gt; [ // ... App\\Providers\\CustomServiceProvider::class,], 创建自定义服务类： 创建一个用于提供服务的自定义类，例如： 1234567891011&lt;?phpnamespace App\\Services;class CustomService&#123; public function doSomething() &#123; return &quot;Doing something!&quot;; &#125;&#125; 使用你的自定义门面： 在任何地方都可以使用你的自定义门面来调用服务，而不需要实例化服务类： 123use App\\Facades\\CustomFacade;CustomFacade::doSomething(); // 将调用 CustomService 中的 doSomething 方法 这样，你就创建了一个自定义门面并将其与一个自定义服务相关联。在使用门面时，它会代理到相应的服务提供者中注册的服务实例上。这使得你可以以简单直观的方式在应用程序中访问和使用自定义服务。 laravel 常用的250个技巧","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"hyperf","slug":"php/hyperf","permalink":"http://example.com/categories/php/hyperf/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"hyperf","slug":"hyperf","permalink":"http://example.com/tags/hyperf/"}]},{"title":"hyperf","slug":"php/hyperf","date":"2023-07-18T06:13:00.000Z","updated":"2023-07-18T06:30:26.122Z","comments":true,"path":"2023/07/18/php/hyperf/","link":"","permalink":"http://example.com/2023/07/18/php/hyperf/","excerpt":"","text":"hyperf 设置根目录静态资源访问 config&#x2F;server.php swoole server配置 123&#x27;document_root&#x27; =&gt; BASE_PATH.&#x27;/web&#x27;,&#x27;static_handler_locations&#x27; =&gt; [&#x27;/&#x27;],&#x27;enable_static_handler&#x27; =&gt; true, web目录访问 ： http://127.0.0.1:9501/index.html hyperf 生成控制器 12345php bin/hyperf.php gen:controller -N App\\Wechat\\Controller ttphp bin/hyperf.php gen:controller -N App\\Admin\\Controller TalkTagphp bin/hyperf.php gen:model --path=app/SaasModel --pool=saas -i=BaseModel goods_order 导出excel, 6w数据分批导出,大概 20s 单次db 1w条数据1.导出excel文件存放storage/xx.xls2.$this-&gt;response-&gt;download(&#39;filepath&#39;,&#39;filename&#39;) 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace App\\Wechat\\WxUtils;use PhpOffice\\PhpSpreadsheet\\IOFactory;use PhpOffice\\PhpSpreadsheet\\Spreadsheet;class Excel&#123; private $sheet; private $spreadsheet; private $row; public function __construct() &#123; $this-&gt;spreadsheet = new Spreadsheet(); $this-&gt;spreadsheet-&gt;setActiveSheetIndex(0); $this-&gt;sheet = $this-&gt;spreadsheet-&gt;getActiveSheet(); $this-&gt;spreadsheet-&gt;getActiveSheet()-&gt;setTitle(&#x27;Sheet1&#x27;); &#125; public function setHeader($title) &#123; foreach ($title as $key =&gt; $item) &#123; $this-&gt;sheet-&gt;setCellValue(chr($key + 65).&#x27;1&#x27;, $item); &#125; $this-&gt;row = 2; // 从第二行开始 return $this; &#125; public function addData($data) &#123; foreach ($data as $item) &#123; $dataCol = &#x27;A&#x27;; foreach ($item as $value) &#123; // 单元格内容写入 $this-&gt;sheet-&gt;setCellValue($dataCol.$this-&gt;row, $value); $dataCol++; &#125; $this-&gt;row++; &#125; return $this; &#125; public function save($fileName) &#123; $this-&gt;spreadsheet-&gt;setActiveSheetIndex(0); $fileName = $fileName.&#x27;.xlsx&#x27;; $url = &#x27;/storage/&#x27;.$fileName; $outFilename = BASE_PATH.$url; $writer = IOFactory::createWriter($this-&gt;spreadsheet, &#x27;Xlsx&#x27;); $writer-&gt;save($outFilename); $this-&gt;spreadsheet-&gt;disconnectWorksheets(); unset($this-&gt;spreadsheet); return [&#x27;path&#x27; =&gt; $outFilename, &#x27;filename&#x27; =&gt; $fileName]; &#125;&#125; 缓存 key mutex 问题 key mutex 微博cache key 目标 ： 尽量少的线程（或者1个线程）来构建换成 1.使用 mutex key 使用1个线程来构建缓存 ，其他线程等待构建缓存的线程执行完即可 123456789101112131415161718 参考代码 String get(String key) &#123; String value = redis.get(key); if (value == null) &#123; if (redis.setnx(key_mutex, &quot;1&quot;)) &#123; // 3 min timeout to avoid mutex holder crash redis.expire(key_mutex, 3 * 60) value = db.get(key); redis.set(key, value); redis.delete(key_mutex); &#125; else &#123; //其他线程休息50毫秒后重试 Thread.sleep(50); get(key); &#125; &#125; &#125; “提前”使用互斥锁(mutex key) 在value 中设置1个 time_out 时间戳 12345678910111213141516171819202122232425262728v = memcache.get(key); if (v == null) &#123; if (memcache.add(key_mutex, 3 * 60 * 1000) == true) &#123; value = db.get(key); memcache.set(key, value); memcache.delete(key_mutex); &#125; else &#123; sleep(50); retry(); &#125; &#125; else &#123; if (v.timeout &lt;= now()) &#123; if (memcache.add(key_mutex, 3 * 60 * 1000) == true) &#123; // extend the timeout for other threads v.timeout += 3 * 60 * 1000; memcache.set(key, v, KEY_TIMEOUT * 2); // load the latest value from db v = db.get(key); v.timeout = KEY_TIMEOUT; memcache.set(key, value, KEY_TIMEOUT * 2); memcache.delete(key_mutex); &#125; else &#123; sleep(50); retry(); &#125; &#125; &#125; 3.永不过期 博客 @@ 缓存雪崩 ： 设置缓存时，key都采用了相同expire 缓存服务宕机 实现熔断限流机制，对系统进行负载能力控制, 在原有失效时间基础上增加一个随机值，比如1~5分钟的随机，这样每个缓存的过期时间重复率就会降低，集体失效概率也会大大降低 限流或者降级 例如5w个请求,先允许2w 部分请求先进来, 其他3w请求打到写好限流中间件返回空值或者默认值 @@ 缓存穿透 大量并发查询一个不存在的key 导致数据库流量都打到数据库 Bloom过滤或RoaringBitmap 判断KEY是否存在 【 最常见的布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力】 怎么理解 ：数据库ID 1-100000 每条插入的时候id 插入到布隆过器里面， 使用布隆过滤器进行过滤 缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY @@ 缓存穿透 某KEY失效时，正好有大量并发请求访问该KEY 缓存 + 过期时间 存储一个value 进行提前重设 事务隔离级别 脏读（dirty read） 由上图可以发现，事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读 事务A需要读到100的余额 不可重复读（unrepeatable read） 事务A又被事务B干扰到了！在事务A范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读 幻读 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入&#x2F;删除了数据，，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读 事务四大隔离级别 读未提交（Read Uncommitted） 事务读不加锁，不阻塞其他事务的读和写事务写阻塞其他事务写，但不阻塞其他事务读； 读已提交（Read Committed） 可重复读（Repeatable Read） 串行化（Serializable） tcp协议部分 a记录一次swoole 4.8升级安装报错问题源码包编译安装 1PHP Warning: PHP Startup: Unable to load dynamic library &#x27;swoole.so&#x27; (tried: /usr/local/php/lib/php/extensions/no-debug-non-zts-20190902/swoole.so (/usr/local/php/lib/php/extensions/no-debug-non-zts-20190902/swoole.so: undefined symbol: curl_CURLFile_class), /usr/local/php/lib/php/extensions/no-debug-non-zts-20190902/swoole.so.so (/usr/local/php/lib/php/extensions/no-debug-non-zts-20190902/swoole.so.so: cannot open shared object file: No such file or directory)) in Unknown on line 0 在php.ini中先加载curl extension=curl.so extension=swoole.so 这样会导致重复加载curl.so , 在mod_目录中 curl.ini中下面加上swoole.so swoole版本升级 wsl 内部没有局域网ip 只能通过代理转发1234567 netsh interface portproxy add v4tov4 listenport=12000 listenaddress=0.0.0.0 connectport=9999 connectaddress=127.0.0.1 protocol=tcp9999：为内部wsl 服务端口172.27.240.162 ：为wsl 内部ip 查看端口转发状态1netsh interface portproxy show all 删除端口转发： 123netsh interface portproxy delete v4tov4 listenport=* listenaddress=0.0.0.0*代表所有端口，0.0.0.0为所有ip","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"hyperf","slug":"php/hyperf","permalink":"http://example.com/categories/php/hyperf/"}],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"hyperf","slug":"hyperf","permalink":"http://example.com/tags/hyperf/"}]},{"title":"wsl2使用","slug":"工具/wsl","date":"2023-07-18T06:05:57.000Z","updated":"2023-07-18T06:08:22.163Z","comments":true,"path":"2023/07/18/工具/wsl/","link":"","permalink":"http://example.com/2023/07/18/%E5%B7%A5%E5%85%B7/wsl/","excerpt":"","text":"设置默认启动 1234567891011 ubuntu config --default-user root add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; service ssh --full-restart端口转发iex &quot;netsh interface portproxy add v4tov4 listenport=12000 listenaddress= 192.168.19.117 connectport=8888 connectaddress=127.0.0.1&quot;;git config --global core.autocrlf false","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"windows wsl","slug":"linux/windows-wsl","permalink":"http://example.com/categories/linux/windows-wsl/"}],"tags":[{"name":"wsl2","slug":"wsl2","permalink":"http://example.com/tags/wsl2/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"}]},{"title":"mac","slug":"工具/mac","date":"2023-07-18T06:05:57.000Z","updated":"2023-09-21T01:08:22.812Z","comments":true,"path":"2023/07/18/工具/mac/","link":"","permalink":"http://example.com/2023/07/18/%E5%B7%A5%E5%85%B7/mac/","excerpt":"","text":"mac 电脑的全新下载 下载源 码云地址： https://gitee.com/cunkai/HomebrewCN mac 阿里云源 https://developer.aliyun.com/mirror/homebrew/?spm=a2c6h.25603864.0.0.4c795129L0K5fb","categories":[{"name":"mac","slug":"mac","permalink":"http://example.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://example.com/tags/mac/"}]},{"title":"vue笔记","slug":"前端/前端","date":"2023-07-18T01:10:56.000Z","updated":"2023-07-18T01:11:49.220Z","comments":true,"path":"2023/07/18/前端/前端/","link":"","permalink":"http://example.com/2023/07/18/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF/","excerpt":"","text":"参考资料","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[]},{"title":"面试总结","slug":"面试/面试","date":"2023-07-18T01:10:02.000Z","updated":"2023-07-18T01:10:28.173Z","comments":true,"path":"2023/07/18/面试/面试/","link":"","permalink":"http://example.com/2023/07/18/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/","excerpt":"","text":"参考资料","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"总结","slug":"面试/总结","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"git笔记","slug":"工具/git","date":"2023-07-18T01:07:28.000Z","updated":"2023-08-04T09:48:54.517Z","comments":true,"path":"2023/07/18/工具/git/","link":"","permalink":"http://example.com/2023/07/18/%E5%B7%A5%E5%85%B7/git/","excerpt":"","text":"git忽略文件权限git config --global core.filemode false 在最后一条记录，可以看到信息为：“ checkout: moving from master to develop”，表示develop分支是从master分支“移动”过去的，也就是develop分支是基于master分支拉取的git reflog show --date=local | grep 当前分支名 一次性推送本地所有标签git push origin --tags git中如何合并某个指定文件分支A_bracn和B_branch，只想将A_branch分支的某个文件f.txt合并到B_branch分支上。 git checkout A_branch git checkout --patch B_branch f.txt第一个命令： 切换到A分支；第二个命令：合并B分支上f文件到A分支上，将B分支上 f 文件追加补丁到A分支上 f文件。你可以接受或者拒绝补丁内容。 如果只是简单的将A_branch分支的文件f.txt copy到B_branch分支上 git checkout B_branchcd path&#x2F;to&#x2F;f.txtgit checkout A_bracn f.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332# 显示详细的修改状态$ git status # 以短格式显示状态,更简洁$ git status -s # 顺便显示当前分支名$ git status -b# 显示忽略的文件$ git status --ignored# 显示工作区与暂存区的差异。$ git diff # 显示暂存区与仓库的差异$ git diff --staged $ git diff --cached# 显示工作区与仓库的差异$ git diff HEAD# 显示两个提交之间的差异$ git diff 02d1a7b d2974d6# 显示两个分支之间的差异。$ git diff dev master# 导出差异文件成压缩包$ git diff --name-only 144d196 188df06a | xargs tar -cvf pacakge.tar.gz# 提交暂存区的修改,并添加提交信息,生成commit id$ git commit -m &quot;message&quot;# 提交工作区和暂存区的所有修改,不包含新建的文件$ git commit -am &quot;message&quot;# 修改最后一次提交的信息$ git commit --amend# 绕过钩子程序$ git commit --no-verify# 允许空白提交,git tag可能会用到$ git commit --allow-empty# 放弃对工作区文件的修改,恢复到仓库HEAD的状态,可用正则匹配$ git restore hello.c $ git restore &#x27;*.c&#x27;$ git restore .# 恢复工作区文件到指定提交的状态$ git restore --source 7d68213 hello.c$ git restore -s 7d68213 hello.c# 仅恢复暂存区的文件到HEAD状态,不影响工作区,相当于撤销git add hello.c操作$ git restore --staged hello.c# 重置HEAD为指定提交,重置暂存区但保留工作区修改$ git reset 7d68213$ git reset --mixed 7d68213# 重置HEAD为指定提交,但保留工作区修改$ git reset --soft 7d68213# 回滚HEAD两个版本,但保留工作区修改$ git reset --soft HEAD~2# 重置HEAD为指定提交,重置暂存区和工作区,丢弃所有修改$ git reset --hard dc7ccb1# 重置时保留未跟踪文件。$ git reset --mixed --keep 2d3a2b9# 删除指定文件,并提交移除操作到暂存区,删除前会检查文件状态,以免误删未提交的修改。$ git rm index.php# 删除指定文件,并提交移除操作到暂存区,删除前不会检查文件状态$ git rm -f index.php# 删除暂存区和仓库中的文件,但保留工作区中的文件$ git rm --cached xx.log# 递归删除整个目录$ git rm -r runtime/# 删除目录中的所有文件的暂存区和仓库版本,但保留工作区中的文件,一般用于.gitignore文件添加.idea文件夹时,把.idea从暂存区和仓库删掉同时保留工作区文件$ git rm -r --cached .idea/# 列出本地所有分支$ git branch# 创建本地新分支$ git branch feature/devlop# 删除本地分支,只能删除已合并的分支,或者HEAD和master一致的分支(还没commit过)$ git branch -d feature/devlop# 删除本地分支,可以删除未合并的分支$ git branch -D feature/devlop# 列出本地分支及其最后一个提交$ git branch -v# 列出本地已经合并到当前分支的分支$ git branch --merged# 列出尚未合并到当前分支的分支$ git branch --no-merged# 列出本地和远程所有分支$ git branch -a# 重命名分支$ git branch -m master main# 复制一个分支到新创建的分支上,拥有前分支完整的历史$ git branch -c new_branch# 将本地分支与指定的远程分支建立追踪关系。$ git branch --set-upstream-to main main# 删除对远程分支的追踪设置。$ git branch --unset-upstream new_branch# 从 c83c925f6 提交处创建新的分支。$ git branch test c83c925f6# 切换到指定分支$ git checkout master:切换到指定分支# 创建新分支并切换到该分支$ git checkout -b develop# 丢弃工作区的修改,恢复与暂存区一致的版本$ git checkout -- index.php# 工作区中文件的版本回滚到仓库指定提交$ git checkout cdc5737 -- index.php# 切换到指定tag所指向的提交,配合rebase使用可以在重要的标记状态继续工作,同时不必担心丢失之前的提交$ git checkout v1.0# 将指定分支 develop 合并到当前分支,如果可以快进则快进,如果不能快进则创建一个新的合并提交,保留完整的分支记录# 快进指的是如果develop HEAD是master HEAD的上游,则可以直接把master HEAD改成develop HEAD$ git merge develop# 禁用快进,创建一个新的合并提交,即使可以进行快进合并,保留完整的分支记录,常用于开发阶段$ git merge --no-ff develop# 仅在可以进行快进合并时才会合并指定分支$ git merge --ff-only develop# 将指定分支 develop 的多个提交压缩到一个提交,合并到当前分支的暂存区,需要手动提交$ git merge --squash develop# 执行合并但不创建提交,需要手动提交$ git merge --no-commit develop# 显示最近两次提交$ git log -2# 显示某个作者的提交日志 $ git log --author=&quot;ben&quot;# 显示某个日期范围内的提交 $ git log --since=1.month --until=&quot;2018-02-28&quot;# 显示包含某个关键词的提交$ git log --grep=&quot;README&quot;# 显示某个文件被修改的历史 $ git log --follow README.md# 一条命令显示简洁日志、分支和版本标签$ git log --oneline --decorate --all --graph# 显示提交统计信息 $ git log --stat# 显示某个tag到当前提交的日志 $ git log v1.0.0..HEAD# 显示某个tag和最后一个tag之间的所有提交git log v1.0.0..v1.2.1# 显示某个分支的日志$ git log master# 显示所有存储的stash,可以使用git stash apply恢复指定的stash。$ git stash list# 显示指定stash的更改信息,不恢复stash。$ git stash show stash@&#123;0&#125;# 以补丁的形式显示更改信息。$ git stash show -p# 恢复指定的stash到一个新分支上。$ git stash branch new_branch# 恢复最近一次的stash,并从stash list中移除它。$ git stash pop# 从stash list中移除一个stash,不会恢复它。$ git stash drop# 清除所有stash。$ git stash clear# 恢复指定的stash,但是不从stash list中移除它,可以用于测试恢复效果。$ git stash apply stash@&#123;0&#125;# 保存当前工作并添加注释,便于之后查找恢复。$ git stash save &quot;some comments&quot;# 交互式地选择要暂存的更改部分,不保存全部的工作进度。$ git stash save --patch# 只暂存已经添加至暂存区的更改,未添加的更改不会被暂存。$ git stash save --keep-index# 打一个轻量级标签$ git tag v1.0# 打一个带注释的标签$ git tag -a v2.0 -m &quot;Release version 2.0&quot;# 给过去的某次提交打标签$ git tag -a v1.1 9fa1799# 查看v1.1的标签信息和提交信息$ git show v1.1# 从标签v1.1创建新分支$ git checkout -b release-v1.1 v1.1# 删除本地标签v1.1$ git tag -d v1.1# 推送单个新标签到远程$ git push origin v1.0# 推送所有新标签到远程$ git push origin --tags# 删除远程标签$ git tag -r &lt;tagname&gt;# 获取所有远程仓库最新提交:$ git fetch --all# 查看本地和远程仓库差异,然后合并$ git log origin/dev..dev$ git diff origin/dev dev$ git merge# 只获取origin远程仓库master分支的最新两个提交$ git fetch origin master --depth 2# 获取origin远程仓库,并清除服务器上已经删除的分支$ git fetch --prune origin# 将一个浅仓库转为完整仓库:$ git fetch --unshallow# 预览将要获取的提交,但不实际获取$ git fetch --dry-run# 从origin远程仓库获取master分支并合并: $ git pull origin master# 使用rebase合并:$ git pull --rebase# 只在可以快速向前合并的情况下进行合并:$ git pull --ff-only# 从所有远程仓库获取数据并合并: $ git pull --all# 删除远程仓库origin并更新引用:$ git pull -d origin# 拉取远程仓库的标签$ git pull --tags# 推送master分支到origin远程仓库: $ git push origin master# 推送全部本地分支到origin:$ git push origin --all# 删除远程仓库origin的dev分支:$ git push origin --delete dev# 强制推送master分支到origin,会覆盖远程分支:$ git push origin master --force# 只有在远程master分支是当前master分支的上游分支时,才强制推送:$ git push origin master --force-with-lease# 推送所有标签到远程仓库$ git push &lt;remote&gt; --tagsgit remote add origin https://github.com/user/repo.gitgit remote add upstream https://gitlab.com/user/repo.git git remote add alias https://bitbucket.org/user/repo.git# 列出当前所有的远程仓库别名$ git remote# 添加一个新的远程仓库origin,URL为https://github.com/user/repo.git$ git remote add origin https://github.com/user/repo.git# 重命名远程仓库upstream为up$ git remote rename upstream up# 移除远程仓库up$ git remote remove up# 修改远程仓库origin的URL$ git remote set-url origin https://gitee.com/user/repo.git# 列出远程仓库origin的详细信息$ git remote show origin# 显示HEAD指向的提交信息$ git show# 显示master分支的最新提交815e1c2的信息$ git show 815e1c2# 仅显示该提交修改的文件列表$ git show 815e1c2 --name-only# 显示该提交的文件差异 $ git show 815e1c2 -p# 以medium格式显示提交信息$ git show 815e1c2 --pretty=medium# 显示要应用提交815e1c2,需要运行的cherry-pick命令$ git show 815e1c2 --cherry-pick# 显示所有提交的简要日志,按提交者排序$ git shortlog# 仅显示最近10次提交$ git shortlog -n 10# 显示提交者和提交次数的汇总,不显示提交摘要$ git shortlog -s# 显示所有提交者的邮箱和提交SHA-1校验和$ git shortlog -e --all# 查找master最近5次变更$ git reflog show master | head - 5750c435 (HEAD -&gt; master) master@&#123;0&#125;: commit: xx2d3a2b9 (tag: v1.0) master@&#123;1&#125;: reset: moving to 2d3a2b9ddc7ccb1 master@&#123;2&#125;: reset: moving to dc7ccb12d3a2b9 (tag: v1.0) master@&#123;3&#125;: reset: moving to 2d3a2b9dc# 回滚到master两次改变之前的commit,git log也会恢复$ git reset --hard master@&#123;2&#125;# 撤销最近一次提交 $ git revert HEAD# 撤销指定的提交 $ git revert 8fd4e43# 编辑revert信息$ git revert -e 8fd4e43# 撤销指定提交,不记录revert到操作$ git revert --no-commit 8fd4e43# 将experiment分支rebase到master分支 $ git checkout experiment $ git rebase master# 交互式rebase,合并最近3次提交 $ git rebase -i HEAD~3# 继续rebase操作 $ git rebase --continue # 终止rebase操作 $ git rebase --abort# 应用0001-fix-bug.patch补丁$ git apply 0001-fix-bug.patch# 仅显示应用该补丁后文件的变化统计:$ git apply --stat 0001-fix-bug.patch# 检查补丁是否可以应用成功:$ git apply --check 0001-fix-bug.patch# 应用补丁,更新索引而非工作树$ git apply --cached 0001-fix-bug.patch# 反转补丁的更改$ git apply --reverse 0001-fix-bug.patch# 在无法应用的部分中创建reject文件$ git apply --reject 0001-fix-bug.patch git 分支笔记 git branch //查看分支 git branch dev //新建分支 git checkout -b dev //创建分支并且切换到分支下 git branch -d dev //删除dev 分支 git merge dev //合并分支 git tag 标签git tag -a v1.0 //给目前提交打上标签 git tag -a v0.9 85fc7e7 //为某一个版本追加标签 git tag //查看标签 git tag -d v1.0 //删除某个标签 git show v1.0 //查看某个版本的修改 查看历史提交git log --oneline //正向查看提交历史一行一行 git log --reverse --oneline // 逆向查看提交历史 git log --oneline --graph //以图表形式展示 git diff 比较git diff master..test //比较两个版本的差异 注意是是版本 文件 git diff master...dev //比较两个分支是否存在差异 三个... git diff //显示在当前的工作目录里的，没有 staged(添加到索引中)，且在下次提交时 不会被提交的修改 git diff --cached //当前的索引和上次提交间的差异；这些内容在不带&quot;-a&quot;参数运行 &quot;git commit&quot;命令时就会被提交 git diff HEAD //工作目录与上次提交时之间的所有差别 git diff dev //比较当前分支和dev 分支 文件差异 git diff HEAD -- ./lib //比较某个分支下面的目录 git stash暂存区git stash //暂时隐藏本地修改的内容 恢复到上次条的版本 git stash apply //恢复暂存区的修改 git stash list //显示暂存区的列表 git stash apply stash@&#123;1&#125;&#39; //使用在队列中的任意一个&#39;储藏&#39;(stashes) git stash clear stash@&#123;0&#125; //清空某个暂存 开发错误提交处理git reset --hard HEAD // 如果你现在的工作目录(work tree)里搞的一团乱麻, 但是你现在还没有把它们提交; 你可以通过下面的命令, 让工作目录回到上次提交时的状态(last committed state): git checkout -- hello.rb // 修改某一个文件 还原到上一次提交 //都是针对尚未提交的版本 //如果是针对已经提交了的 进行版本回退 回退后进行提交git push git revert HEAD git revert HEAD^ gitk --all &amp; //后台进程查看图像花提交图像 git pull origin newbranch //拉取指定分支 因为默认clone 是主分支 也是拉取主分支 //本地分支新建分支 推送到远程仓库中那么 进行 git push origin newbranch git push origin newbranch","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"笔记","slug":"git/笔记","permalink":"http://example.com/categories/git/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"python笔记","slug":"python/python","date":"2023-07-18T01:07:18.000Z","updated":"2023-07-18T07:41:38.882Z","comments":true,"path":"2023/07/18/python/python/","link":"","permalink":"http://example.com/2023/07/18/python/python/","excerpt":"","text":"元祖 tulpe (1,2,3) list [1,2,3,4] 字典： {“age”:1,’al’:2} from sqlalchemy.dialects import mysql ！！！前提不要fist() all() 实例对象 sql &#x3D; user.statement.compile(dialect&#x3D;mysql.dialect(), compile_kwargs&#x3D;{“literal_binds”: True}) 参考资料","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"笔记","slug":"python/笔记","permalink":"http://example.com/categories/python/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"docker笔记","slug":"docker/docker","date":"2023-07-18T01:07:08.000Z","updated":"2023-07-18T06:11:19.521Z","comments":true,"path":"2023/07/18/docker/docker/","link":"","permalink":"http://example.com/2023/07/18/docker/docker/","excerpt":"","text":"k8s环境搭建docker 常用命令12345678910111213141516171819202122232425262728293031323334353637docker container ls -a 显示全部 docker container start id/namedocker-compose up -d nginx 构建建启动nignx容器 docker-compose exec nginx bash 登录到nginx容器中 docker-compose down 删除所有nginx容器,镜像 docker-compose ps 显示所有容器 docker-compose restart nginx 重新启动nginx容器 docker-compose run --no-deps --rm php-fpm php -v 在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器 docker-compose build nginx 构建镜像 docker-compose build --no-cache nginx 不带缓存的构建。 docker-compose logs nginx 查看nginx的日志 docker-compose logs -f nginx 查看nginx的实时日志 docker-compose config -q 验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息 docker-compose events --json nginx 以json的形式输出nginx的docker日志 docker-compose pause nginx 暂停nignx容器 docker-compose unpause nginx 恢复ningx容器 docker-compose rm nginx 删除容器（删除前必须关闭容器） docker-compose stop nginx 停止nignx容器 docker-compose start nginx 启动nignx容器","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"},{"name":"笔记","slug":"docker/笔记","permalink":"http://example.com/categories/docker/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"redis笔记","slug":"redis/redis","date":"2023-07-18T01:07:04.000Z","updated":"2023-09-13T06:01:12.728Z","comments":true,"path":"2023/07/18/redis/redis/","link":"","permalink":"http://example.com/2023/07/18/redis/redis/","excerpt":"","text":"经典问题 缓存数据库一致性参考资料 掘金文档地址","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"},{"name":"笔记","slug":"redis/笔记","permalink":"http://example.com/categories/redis/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"php","slug":"yii/php","date":"2023-07-18T01:07:01.000Z","updated":"2023-07-20T06:06:29.350Z","comments":true,"path":"2023/07/18/yii/php/","link":"","permalink":"http://example.com/2023/07/18/yii/php/","excerpt":"","text":"yii迁移文件php74 yii migrate/up --migrationPath=@migrations/mynobid_db/ --db=db_mynobid 阿里云源composer2 config -g repo.packagist composer https://mirrors.aliyun.com/composer/ option+command+p 显示文件的目录路径 command +i 显示简介","categories":[{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"笔记","slug":"php/笔记","permalink":"http://example.com/categories/php/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"mysql","slug":"mysql/mysql","date":"2023-07-18T01:06:54.000Z","updated":"2023-09-27T08:51:19.501Z","comments":true,"path":"2023/07/18/mysql/mysql/","link":"","permalink":"http://example.com/2023/07/18/mysql/mysql/","excerpt":"","text":"msyql 实现排名函数123456789101112131415161718SELECT num, be_help_customer_id, row_number ( ) over ( PARTITION BY brand_id ORDER BY num DESC ) AS r FROM (SELECT count( * ) AS num, mt.be_help_customer_id, mt.brand_id FROM `marketing_task_user_invite` AS `mt` INNER JOIN `customer_relation` AS `cr` ON `cr`.`relation_id` = `mt`.`relation_id` WHERE ( `mt`.`task_id` = &#x27;229&#x27; AND `mt`.`brand_id` = &#x27;3&#x27; AND `mt`.`be_help_customer_id` &gt; &#x27;0&#x27; AND `cr`.`status` = &#x27;1&#x27; ) GROUP BY `be_help_customer_id` ) AS t 链表批量更新123UPDATE orders as o LEFT JOIN orders_writeoff as ow on ow.order_id = o.order_id set ow.use_end_time = 1625673599where o.marketing_id = 4350 1UPDATE admin_role set rule_id =(SELECT GROUP_CONCAT(id) from admin_auth) where data_role =1; 12-- 常用日期FROM_UNIXTIME(created_at,&#x27;%Y-%m&#x27;) months 批量修改表名称1234567891011121314151617SELECT CONCAT( &#x27;ALTER TABLE &#x27;, table_name, &#x27; RENAME TO &#x27;, REPLACE ( table_name, &#x27;ACT_&#x27;, -- 要替换的字符串 &#x27;CAMUNDA_ACT_&#x27; -- 替换为新的字符串 ), &#x27;;&#x27; )FROM information_schema. TABLESWHERE TABLE_SCHEMA = &#x27;jeecg-boot&#x27; -- 数据库名称AND table_name LIKE &#x27;ACT_%&#x27;; -- 匹配表（匹配表名以 sys_ 开头的表） 备份数据123456789101112mysqldump -u root -p atm &gt; atm.sql;insert into mysql.user(Host,User,Password) values(&quot;localhost&quot;,&quot;test&quot;,password(&quot;test&quot;));CREATE USER &#x27;test&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;test&#x27;;grant all privileges on *.* to &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;test&#x27; with grant option;flush privileges;SHOW VARIABLES LIKE &#x27;validate_password%&#x27;; 1234567891011121314151617181920212223242526272829303132333435363738394041-- 今天SELECT DATE_FORMAT(NOW(),&#x27;%Y-%m-%d 00:00:00&#x27;) AS &#x27;今天开始&#x27;;SELECT DATE_FORMAT(NOW(),&#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;今天结束&#x27;;-- 昨天SELECT DATE_FORMAT( DATE_SUB(CURDATE(), INTERVAL 1 DAY), &#x27;%Y-%m-%d 00:00:00&#x27;) AS &#x27;昨天开始&#x27;;SELECT DATE_FORMAT( DATE_SUB(CURDATE(), INTERVAL 1 DAY), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;昨天结束&#x27;;-- 上周SELECT DATE_FORMAT( DATE_SUB( DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) DAY), INTERVAL 1 WEEK), &#x27;%Y-%m-%d 00:00:00&#x27;) AS &#x27;上周一&#x27;;SELECT DATE_FORMAT( SUBDATE(CURDATE(), WEEKDAY(CURDATE()) + 1), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;上周末&#x27;;-- 本周SELECT DATE_FORMAT( SUBDATE(CURDATE(),DATE_FORMAT(CURDATE(),&#x27;%w&#x27;)-1), &#x27;%Y-%m-%d 00:00:00&#x27;) AS &#x27;本周一&#x27;;SELECT DATE_FORMAT( SUBDATE(CURDATE(),DATE_FORMAT(CURDATE(),&#x27;%w&#x27;)-7), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;本周末&#x27;;-- 上面的本周算法会有问题,因为mysql是按照周日为一周第一天,如果当前是周日的话,会把时间定为到下一周.SELECT DATE_FORMAT( DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) DAY), &#x27;%Y-%m-%d 00:00:00&#x27;) AS &#x27;本周一&#x27;;SELECT DATE_FORMAT( DATE_ADD(SUBDATE(CURDATE(), WEEKDAY(CURDATE())), INTERVAL 6 DAY), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;本周末&#x27;;-- 上月SELECT DATE_FORMAT( DATE_SUB(CURDATE(), INTERVAL 1 MONTH), &#x27;%Y-%m-01 00:00:00&#x27;) AS &#x27;上月初&#x27;;SELECT DATE_FORMAT( LAST_DAY(DATE_SUB(CURDATE(), INTERVAL 1 MONTH)), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;上月末&#x27;;-- 本月SELECT DATE_FORMAT( CURDATE(), &#x27;%Y-%m-01 00:00:00&#x27;) AS &#x27;本月初&#x27;;SELECT DATE_FORMAT( LAST_DAY(CURDATE()), &#x27;%Y-%m-%d 23:59:59&#x27;) AS &#x27;本月末&#x27;;SELECT COUNT(*) as total , SUM(IFNULL(ccm.customer_id &gt;0,1,0)) as cusomer_count , SUM(IF(ccm.uid &gt;0 and ccm.customer_id = 0 ,1,0)) as user_count , SUM(IFNULL(ccm.type =1,1,0)) as staff_count FROM customer_crowd_member as ccm LEFT JOIN customer_crowd as cc on ccm.crowd_id = cc.crowd_id where cc.crowd_id = 318 时间日期：今天凌点转时间戳 1234SELECT count(*) FROM order_v3 where channel_id=&quot;AOU0002XB3&quot; and status_pay =40 and created_at &gt; UNIX_TIMESTAMP(CURRENT_DATE); 参考资料 msyql原文地址","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"笔记","slug":"mysql/笔记","permalink":"http://example.com/categories/mysql/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"mysql-用户-权限","slug":"mysql/mysql-1","date":"2023-07-18T01:06:54.000Z","updated":"2023-09-27T03:22:32.397Z","comments":true,"path":"2023/07/18/mysql/mysql-1/","link":"","permalink":"http://example.com/2023/07/18/mysql/mysql-1/","excerpt":"","text":"mysql授权一个已经存在的用户所有权限docker 容器创建mysql 要登陆容器后进行授权允许所有外部ip访问 12345678//如果用户存在则不需要创建CREATE USER &#x27;test&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;test&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;test&#x27;@&#x27;%&#x27;;FLUSH PRIVILEGES;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"笔记","slug":"mysql/笔记","permalink":"http://example.com/categories/mysql/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"mysql 用户 权限","slug":"mysql-用户-权限","permalink":"http://example.com/tags/mysql-%E7%94%A8%E6%88%B7-%E6%9D%83%E9%99%90/"}]},{"title":"mongodb笔记","slug":"mongo/mongodb","date":"2023-07-18T01:03:53.000Z","updated":"2023-07-18T07:52:55.233Z","comments":true,"path":"2023/07/18/mongo/mongodb/","link":"","permalink":"http://example.com/2023/07/18/mongo/mongodb/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364age &gt; 10 and title = &quot;bbb&quot;db.mycol.find( &#123;$and : [ &#123;&quot;age&quot;:&#123;$gt:10&#125;&#125; , &#123;&quot;title&quot;: &quot;bbb&quot;&#125;]&#125;) or条件db.article.find(&#123;&quot;$or&quot;: [&#123;&quot;title&quot;: &quot;mongodb&quot;&#125;, &#123;&quot;author&quot;: &quot;god&quot;&#125;]&#125;)模糊mysql like title like &quot;%mongodb%&quot;db.article.find(&#123;&quot;title&quot;: &#x27;/mongodb/&#x27;&#125;)排序order by read descdb.article.find(&#123;&quot;type&quot;: &quot;mongodb&quot;&#125;).sort(&#123;&quot;read&quot;: -1&#125;)递增或递减（$inc）db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123; &quot;$inc&quot;: &#123;&quot;count&quot;: 10&#125;&#125;) // 每次count都加10db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123; &quot;$push&quot;: &#123;&quot;score&quot;: 123&#125;&#125;)还可以一次追加多个元素：db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$push&quot;: &#123;&quot;score&quot;: [12,123]&#125;&#125;)一次追加多个元素（$pushAll）：db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$pushAll&quot;: &#123;&quot;score&quot;: [12,123]&#125;&#125;)追加不重复元素（$addToSet） $addToSet类似集合Set，只有当这个值不在元素内时才增加db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$addToSet&quot;: &#123;&quot;score&quot;: 123&#125;&#125;)//$pop每次只能删除数组中的一个元素，1表示删除最后一个，-1表示删除第一个。删除最后一个元素db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$pop&quot;: &#123;&quot;score&quot;: 1&#125;&#125;)删除第一个元素db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$pop&quot;: &#123;&quot;score&quot;: -1&#125;&#125;)删除特定元素（$pull）db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$pull&quot;: &#123;&quot;score&quot;: 123&#125;&#125;)db.getCollection(&quot;log_api&quot;).find(&#123;&quot;group&quot;:&quot;none\\\\bid_v3\\\\models\\\\forms\\\\epointupv2\\\\Checkbaohan&quot;&#125;).sort(&#123;&#x27;created_at&#x27;:-1&#125;)//mongodb查询 log_api 渠道请求日志db.getCollection(&quot;log_api&quot;).find(&#123;&quot;apiname&quot;:&quot;Baohanrestore&quot;,&quot;created_at&quot;:&#123;$gt:1671758672&#125;&#125;).sort(&#123;&quot;created_at&quot;:-1&#125;)//模糊查询db.log_api.find(&#123;&quot;accountid&quot;:96,&quot;response&quot;:&quot;无效的key|解密失败&quot;,&quot;request&quot;: /&quot;kaibiaotime&quot;:&quot;2023-04-24 09:30:00&quot;/&#125;).sort(&#123;&quot;created_at&quot;:-1&#125;)//mongodb 查询日志db.log_api.find(&#123; created_at: &#123; $gte: 1664352000, $lte: 1664355600 &#125;, apiname: &quot;InvoiceNotice&quot;, request:&#123;$regex:&quot;1202222190056041154&quot;&#125;&#125;)//正则匹配db.log_api.find(&#123; apiname: mb.regex.contains(&quot;sd&quot;)&#125;) db.getCollection(&quot;log_api&quot;).find(&#123;&quot;apiname&quot;:&quot;Quitapply&quot;,&quot;accountid&quot;:28&#125;).sort(&#123;&quot;created_at&quot;:-1&#125;) 参考资料 mongodb操作数据库 分组聚合mongodb","categories":[{"name":"mongodb","slug":"mongodb","permalink":"http://example.com/categories/mongodb/"},{"name":"常用","slug":"mongodb/常用","permalink":"http://example.com/categories/mongodb/%E5%B8%B8%E7%94%A8/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://example.com/tags/mongodb/"}]},{"title":"linux笔记","slug":"docker/linux-1","date":"2023-07-18T01:00:46.000Z","updated":"2023-09-21T02:19:30.922Z","comments":true,"path":"2023/07/18/docker/linux-1/","link":"","permalink":"http://example.com/2023/07/18/docker/linux-1/","excerpt":"","text":"1234567891011121314151617181920212223242526272829function git_branch &#123; branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\\*&quot; | sed -e &quot;s/^\\*\\ //&quot;`&quot; if [ &quot;$&#123;branch&#125;&quot; != &quot;&quot; ];then if [ &quot;$&#123;branch&#125;&quot; = &quot;(no branch)&quot; ];then branch=&quot;(`git rev-parse --short HEAD`...)&quot; fi echo &quot; ($branch)&quot; fi&#125;export PS1=&#x27;\\u \\[\\033[01;36m\\]\\W\\[\\033[01;32m\\]$(git_branch)\\[\\033[00m\\] \\$ &#x27;编辑环境变量~/.bashrc//刷新配置source ~/.bashrc# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备（yum install pciutils）# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量 正确删除k8s pod容器命令123kubectl delete deployment &lt;deployment名&gt; -n &lt;namespace&gt;例如：kubectl delete deployment nginx-web -n yundoc 在 Kubernetes 中，可以使用 hostPath 来将本地节点上的目录挂载到 Pod 内。这对于需要访问节点文件系统的情况非常有用，但请注意这可能会带来一些安全和可移植性方面的问题。以下是一个基本的示例： 创建一个本地目录： 在你的 Kubernetes 节点上创建一个本地目录，该目录将用于存储你想要挂载到容器内的文件或数据。 1mkdir /path/to/host/dir 创建一个 YAML 文件： 创建一个 YAML 文件，例如 pod-with-hostpath.yaml，并定义 Pod 的配置，将 hostPath 用于挂载目录。 123456789101112131415apiVersion: v1kind: Podmetadata: name: my-podspec: containers: - name: my-container image: &lt;your-image&gt; volumeMounts: - name: hostpath-volume mountPath: /path/inside/container volumes: - name: hostpath-volume hostPath: path: /path/to/host/dir 请将 &lt;your-image&gt; 替换为你实际使用的容器镜像。 在这个示例中，我们创建了一个 Pod，将本地节点上的 /path/to/host/dir 目录挂载到了容器内的 /path/inside/container。 应用配置： 使用 kubectl apply -f 命令来将配置文件应用到集群中： 1kubectl apply -f pod-with-hostpath.yaml Kubernetes 将会创建 Pod，并将本地目录挂载到容器内。 请注意： 使用 hostPath 可能会带来安全风险，因为容器可以访问节点上的任何文件。请谨慎使用并确保限制访问权限。 由于 hostPath 使用本地节点的路径，这将会影响到 Pod 的可移植性。如果需要在不同节点之间迁移 Pod，建议考虑其他持久化存储解决方案，如 NFS、CSI 等。 如果你在 Kubernetes 中运行的容器内部暴露了一个临时端口，你需要一种方法来使这个端口可从物理机访问。有几种方法可以做到这一点，以下是其中一些选项：1. 使用 kubectl port-forward你可以使用 kubectl port-forward 命令来将容器的端口映射到本地机器上，从而可以从物理机访问容器服务。 1kubectl port-forward &lt;pod-name&gt; &lt;local-port&gt;:&lt;container-port&gt; 例如，如果你的容器名称是 my-container，临时服务运行在容器的端口 8080，你可以运行以下命令： 1kubectl port-forward my-container 8080:8080 现在你可以在物理机上使用 localhost:8080 访问容器服务。 2. 使用 NodePort 类型的 Service你可以创建一个 NodePort 类型的 Service，它会将容器内的端口暴露到所有节点的相同端口上。 123456789101112apiVersion: v1kind: Servicemetadata: name: my-temp-servicespec: type: NodePort selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 # 这里指定容器内临时服务的端口 然后通过 kubectl apply -f my-service.yaml 将配置应用到集群中。Kubernetes 将会为 Service 分配一个随机的高端口号（例如：30XXX），你可以使用这个端口来访问容器服务。 3. 使用 LoadBalancer 类型的 Service如果你的集群运行在云环境中（如 AWS、GCP、Azure 等），你可以使用 LoadBalancer 类型的 Service 来将服务暴露到公共互联网。 123456789101112apiVersion: v1kind: Servicemetadata: name: my-temp-servicespec: type: LoadBalancer selector: app: my-app ports: - protocol: TCP port: 80 targetPort: 8080 # 这里指定容器内临时服务的端口 然后通过 kubectl apply -f my-service.yaml 将配置应用到集群中。Kubernetes 将会创建一个云提供商特定的负载均衡器，并将流量转发到服务的端口上。 请注意，这些方法中的每一个都有适用的场景，具体取决于你的部署环境和要求。选择一个方法时，请确保你的网络配置和安全规则允许流量流向暴露的端口。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"基础","slug":"linux/基础","permalink":"http://example.com/categories/linux/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"linux常用基础命令","slug":"docker/linux","date":"2023-07-18T01:00:44.000Z","updated":"2023-10-07T09:55:39.108Z","comments":true,"path":"2023/07/18/docker/linux/","link":"","permalink":"http://example.com/2023/07/18/docker/linux/","excerpt":"","text":"文件大小排序1du -ah | sort -rn 下载指定的文件 解决mac无法lrsz命令1scp root@192.168.1.204:/var/wwwroot/zlyadmin-dev11/console/runtime/huashang_tb/20230712.log ./ linux某个进程查看1cat /proc/25001/cmdline linux进程的详细参数1ll /proc/25001 文件压缩文件夹1zip -q -r html.zip /home/Blinux/html 解压到指定文件目录1unzip test.zip -d /data grep查找关键字1grep -r &quot;test&quot; /data/reports 杀死特定端口号的进程12345kill -9 lsof -i:18100 | awk &#x27;NR==2&#123;print $2&#125;&#x27;kill -9 lsof -i | grep 18100 | awk &#x27;&#123;print $2&#125;&#x27;kill -9 ss -antlup | grep 18100 | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&#x27;[=,]&#x27; &#x27;&#123;print $3&#125;&#x27; 删除文件节点123456ls -ifind -inum 133945 -exec rm -rf &#123;&#125; \\;grep -10 &#x27;123&#x27; test.log grep 是一个在Linux和Unix系统中用于搜索文本的强大命令行工具。它可以用来在文件中查找包含特定模式或关键字的行，并将匹配的行输出到屏幕上。 以下是一些常用的 grep 命令示例： 基本的关键字搜索： 1grep &#x27;关键字&#x27; 文件名 例如，如果要在文件 example.txt 中搜索关键字 “hello”，可以使用以下命令： 1grep &#x27;hello&#x27; example.txt 忽略大小写： 1grep -i &#x27;关键字&#x27; 文件名 例如，如果你希望搜索时忽略大小写，可以使用 -i 选项： 1grep -i &#x27;hello&#x27; example.txt 显示行号： 1grep -n &#x27;关键字&#x27; 文件名 这会显示匹配行的行号： 1grep -n &#x27;hello&#x27; example.txt 显示匹配行之前的行数： 1grep -B 2 &#x27;关键字&#x27; 文件名 这将显示匹配行之前的2行： 1grep -B 2 &#x27;hello&#x27; example.txt 显示匹配行之后的行数： 1grep -A 2 &#x27;关键字&#x27; 文件名 这将显示匹配行之后的2行： 1grep -A 2 &#x27;hello&#x27; example.txt 显示匹配行及其上下文： 1grep -C 2 &#x27;关键字&#x27; 文件名 这将显示匹配行的前后2行： 1grep -C 2 &#x27;hello&#x27; example.txt 递归搜索目录： 1grep -r &#x27;关键字&#x27; 目录名 这将在指定目录及其子目录中递归搜索： 1grep -r &#x27;hello&#x27; /path/to/directory 反向匹配（显示不包含关键字的行）： 1grep -v &#x27;关键字&#x27; 文件名 这将显示不包含关键字的所有行： 1grep -v &#x27;hello&#x27; example.txt 这些只是 grep 的一些基本用法。它提供了许多选项和功能，可以根据具体的需求进行定制。可以通过 man grep 命令来查看 grep 的详细帮助文档，以了解更多选项和用法。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"基础","slug":"linux/基础","permalink":"http://example.com/categories/linux/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"笔记","slug":"git/笔记","permalink":"http://example.com/categories/git/%E7%AC%94%E8%AE%B0/"},{"name":"laravel","slug":"laravel","permalink":"http://example.com/categories/laravel/"},{"name":"php","slug":"php","permalink":"http://example.com/categories/php/"},{"name":"yii","slug":"php/yii","permalink":"http://example.com/categories/php/yii/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"前端/hexo","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/hexo/"},{"name":"openai","slug":"openai","permalink":"http://example.com/categories/openai/"},{"name":"大语言模型","slug":"openai/大语言模型","permalink":"http://example.com/categories/openai/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"},{"name":"基础","slug":"php/基础","permalink":"http://example.com/categories/php/%E5%9F%BA%E7%A1%80/"},{"name":"记录","slug":"生活/记录","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"},{"name":"golang","slug":"golang","permalink":"http://example.com/categories/golang/"},{"name":"基础","slug":"golang/基础","permalink":"http://example.com/categories/golang/%E5%9F%BA%E7%A1%80/"},{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"笔记","slug":"项目/笔记","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E7%AC%94%E8%AE%B0/"},{"name":"phpstrom","slug":"php/phpstrom","permalink":"http://example.com/categories/php/phpstrom/"},{"name":"hyperf","slug":"php/hyperf","permalink":"http://example.com/categories/php/hyperf/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"windows wsl","slug":"linux/windows-wsl","permalink":"http://example.com/categories/linux/windows-wsl/"},{"name":"mac","slug":"mac","permalink":"http://example.com/categories/mac/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"总结","slug":"面试/总结","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"笔记","slug":"python/笔记","permalink":"http://example.com/categories/python/%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"docker/笔记","permalink":"http://example.com/categories/docker/%E7%AC%94%E8%AE%B0/"},{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"},{"name":"笔记","slug":"redis/笔记","permalink":"http://example.com/categories/redis/%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"php/笔记","permalink":"http://example.com/categories/php/%E7%AC%94%E8%AE%B0/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"笔记","slug":"mysql/笔记","permalink":"http://example.com/categories/mysql/%E7%AC%94%E8%AE%B0/"},{"name":"mongodb","slug":"mongodb","permalink":"http://example.com/categories/mongodb/"},{"name":"常用","slug":"mongodb/常用","permalink":"http://example.com/categories/mongodb/%E5%B8%B8%E7%94%A8/"},{"name":"基础","slug":"linux/基础","permalink":"http://example.com/categories/linux/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"laravel","slug":"laravel","permalink":"http://example.com/tags/laravel/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"yii","slug":"yii","permalink":"http://example.com/tags/yii/"},{"name":"备忘录","slug":"备忘录","permalink":"http://example.com/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"博客构建","slug":"博客构建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA/"},{"name":"openai","slug":"openai","permalink":"http://example.com/tags/openai/"},{"name":"函数 get_headers","slug":"函数-get-headers","permalink":"http://example.com/tags/%E5%87%BD%E6%95%B0-get-headers/"},{"name":"ioc","slug":"ioc","permalink":"http://example.com/tags/ioc/"},{"name":"di","slug":"di","permalink":"http://example.com/tags/di/"},{"name":"外链","slug":"外链","permalink":"http://example.com/tags/%E5%A4%96%E9%93%BE/"},{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"phpstorm","slug":"phpstorm","permalink":"http://example.com/tags/phpstorm/"},{"name":"hyperf","slug":"hyperf","permalink":"http://example.com/tags/hyperf/"},{"name":"wsl2","slug":"wsl2","permalink":"http://example.com/tags/wsl2/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"mac","slug":"mac","permalink":"http://example.com/tags/mac/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"mysql 用户 权限","slug":"mysql-用户-权限","permalink":"http://example.com/tags/mysql-%E7%94%A8%E6%88%B7-%E6%9D%83%E9%99%90/"},{"name":"mongodb","slug":"mongodb","permalink":"http://example.com/tags/mongodb/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]}